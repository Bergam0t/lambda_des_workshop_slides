---
title: "DESperately Seeking Simulation - Part 2"
author:
    name: Sammi Rosser, Dr Dan Chalk
    affiliation: Health Service Modelling Associates Programme Lambda
execute:
  eval: true
  echo: false
format:
  revealjs:
    embed-resources: false # necessary for stlite-quarto embedding to work
    output-file: index.html
    view-distance: 100
    height: 800
    width: 1250
    preview-links: true
    transition: slide
    plotly-connected: true
    background-transition: fade
    preload-iframes: true
    theme: [default, custom.scss]
    title-slide-attributes:
        data-background-image: banner.png
    include-in-header:
      - text: |
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"><link href='https://fonts.googleapis.com/css?family=Lexend' rel='stylesheet'>
    verticator:
      themetag: 'h1'
      color: ''
      inversecolor: ''
      skipuncounted: false
      clickable: true
      position: 'auto'
      offset: '3vmin'
      autogenerate: true
      tooltip: false
      scale: 1
revealjs-plugins:
  - verticator
filters:
  - whitphx/stlite
---

```{python}
#| echo: false

from vidigi.logging import EventLogger
from vidigi.utils import EventPosition, create_event_position_df
from vidigi.animation import animate_activity_log, generate_animation
from vidigi.prep import reshape_for_animations, generate_animation_df
import simpy
import numpy as np

import plotly.io as pio
pio.renderers.default = "notebook"
```

# Recap

## Entities...

Entities are the service users in your model.

Entities arrive and move through your system...

```{python}
#| echo: false

class Patient:
    def __init__(self, p_id):
        self.id = p_id

class SimpleActivityModel:
    def __init__(self, master_seed=42):
        self.env = simpy.Environment()
        self.patient_counter = 0
        self.patient_inter = 5
        self.logger = EventLogger(env=self.env)

        # Seed setup using numpy's SeedSequence
        self.master_seed = master_seed
        self.seed_seq = np.random.SeedSequence(master_seed)
        self.rng = np.random.default_rng(self.seed_seq)

    def generate_arrivals(self):
        while True:
            self.patient_counter += 1
            p = Patient(self.patient_counter)
            self.logger.log_arrival(entity_id=p.id)
            self.env.process(self.patient_journey(p))
            sampled_inter = self.rng.exponential(scale=self.patient_inter)
            yield self.env.timeout(sampled_inter)

    def patient_journey(self, patient):
      self.logger.log_queue(entity_id=patient.id, event="wait_here")
      yield self.env.timeout(10)
      self.logger.log_departure(entity_id=patient.id)

    def run(self):
        self.env.process(self.generate_arrivals())
        self.env.run(until=180)

model = SimpleActivityModel()
model.run()
event_log = model.logger.to_dataframe()
event_log.to_csv("test_log.csv")

animate_activity_log(
  event_log = event_log,
  event_position_df = create_event_position_df([
    EventPosition(event="wait_here", x=200 , y=25 , label="Wait Here!"),
    EventPosition(event="depart", x=300, y=10, label="Exit")
    ]),
  every_x_time_units=1,
  limit_duration=180,
  override_x_max=300,
  override_y_max=50,
  plotly_height=600,
  plotly_width=1200,
  display_stage_labels=False,
  # time_display_units="%M minutes",
  gap_between_entities=20,
  wrap_queues_at=10,
  simulation_time_unit="minutes",
  debug_write_intermediate_objects=True
)
```

## Entities go off and do different things in our model...

```{python}
#| echo: false

class Patient:
    def __init__(self, p_id, path):
        self.id = p_id
        self.path = path

class SimpleActivityModelThreeActivities:
    def __init__(self, master_seed=42):
        self.env = simpy.Environment()
        self.patient_counter = 0
        self.patient_inter = 5
        self.logger = EventLogger(env=self.env)

        # Seed setup using numpy's SeedSequence
        self.master_seed = master_seed
        self.seed_seq = np.random.SeedSequence(master_seed)
        self.rng = np.random.default_rng(self.seed_seq)

    def generate_arrivals(self):
        while True:
            self.patient_counter += 1
            path_sample = self.rng.uniform(low=0.0, high=1.0)

            if path_sample <= 0.2:
                p = Patient(self.patient_counter, path="nurse_consult")
            elif path_sample <= 0.5:
                p = Patient(self.patient_counter, path="blood_test")
            else:
                p = Patient(self.patient_counter, path="doctor_consult")

            self.logger.log_arrival(entity_id=p.id)
            self.env.process(self.patient_journey(p))
            sampled_inter = self.rng.exponential(scale=self.patient_inter)
            yield self.env.timeout(sampled_inter)

    def patient_journey(self, patient):

      self.logger.log_queue(entity_id=patient.id, event=f"wait_here_{patient.path}")

      yield self.env.timeout(self.rng.normal(loc=8, scale=1))

      self.logger.log_departure(entity_id=patient.id)

    def run(self):
        self.env.process(self.generate_arrivals())
        self.env.run(until=180)

model = SimpleActivityModelThreeActivities()
model.run()
event_log = model.logger.to_dataframe()
event_log.to_csv("test_log.csv")

animate_activity_log(
  event_log = event_log,
  event_position_df = create_event_position_df([
    EventPosition(event="wait_here_nurse_consult", x=200 , y=25 , label="Seeing a nurse"),
    EventPosition(event="wait_here_blood_test", x=200 , y=125 , label="Having a blood test"),
    EventPosition(event="wait_here_doctor_consult", x=200 , y=225 , label="Seeing a doctor"),
    EventPosition(event="depart", x=400, y=125, label="Exit")
    ]),
  every_x_time_units=1,
  limit_duration=180,
  override_x_max=300,
  override_y_max=275,
  plotly_height=600,
  plotly_width=1200,
  display_stage_labels=True,
  # time_display_units="%M minutes",
  gap_between_entities=20,
  wrap_queues_at=10,
  simulation_time_unit="minutes",
  debug_write_intermediate_objects=True
)
```

## Generators...

Generators bring entities into being.

We might have multiple generators for different kinds of patients, if they arrive at different rates.

*Example of patients arriving via ambulance and via walk-in, with clearly different arrival rates*


## Sinks

*Example of multi-step mostly linear pathway, with patients having the possibility of leaving at multiple steps*


## Activities and Resources

*Example of simple one-step resource use with a constrained resource*



## Queues

## FIFO Queues

## Priority-based Queue


## Reneging


## Balking


## Jockeying


# What-if Scenarios


## The Power of Questions



## The Code


## Running the Code


# Web App Interfaces

##  {#webappdemo-basic data-menu-title="An Example Web App"}

```{stlite-python}
import micropip

await micropip.install("simpy")
await micropip.install("matplotlib")

import streamlit as st
import simpy
import random
import math
from matplotlib import pyplot as plt
import pandas as pd

# Set page config for wide layout
st.set_page_config(layout="wide")

st.markdown(
    """
    <style>
    [data-testid="stMetricDelta"] svg {
        display: none;
    }
    </style>
    """,
    unsafe_allow_html=True
)

st.title("Healthcare Waiting List Simulation")

# Create two columns
col1, col2 = st.columns([1, 2])

# Left column - Options
with col1:
    st.header("Community Pathway Clinic")

    patients = st.slider(
        "Average new patients per week",
        min_value=5,
        max_value=50,
        value=25,
        help="This sets up a normal distribution with a mean of this value, and a standard deviation of 1/10th of this value."
    )

    waiting_list_start_length = st.number_input(
        "Initial waiting list length",
        min_value=0,
        max_value=5000,
        value=80
    )

    input_col_1, input_col_2 = st.columns([0.4, 0.6])

    clinicians = input_col_1.number_input(
        "Number of\nclinicians",
        min_value=1,
        max_value=20,
        value=4
    )

    patients_per_clinician_per_week = input_col_2.number_input(
        "Patients per clinician\nper week",
        min_value=1,
        max_value=20,
        value=5
    )

    sim_duration_years = st.number_input(
        "Simulation duration (years)",
        min_value=1,
        max_value=10,
        value=3
    )

    run_simulation = st.button("Run Simulation", type="primary")

# Right column - Results
with col2:
    if run_simulation:
        st.header("Simulation Results")

        tab1, tab2, tab3 = st.tabs([
          "Waiting List",
          "Wait Times - Seen",
          "Wait Times - Still Waiting"
          ])

        # Initialize tracking variables
        waiting_times = []
        queue_lengths = []
        time_points = []
        patients_seen = []
        all_patients = []  # Track all patients including those still waiting

        # Set random seed for reproducibility
        random.seed(42)

        def patient(env, name, nurses, arrival_time):
            """A patient arrives, requests a clinician, is seen, and then leaves."""
            service_time = 1 / patients_per_clinician_per_week

            # Record patient in all_patients when they arrive
            patient_record = {
                'name': name,
                'arrival_time': arrival_time,
                'service_start': None,
                'wait_time_weeks': None,
                'status': 'waiting'
            }
            all_patients.append(patient_record)

            with nurses.request() as request:
                yield request
                wait_time = env.now - arrival_time
                waiting_times.append(wait_time)

                # Update patient record when seen
                patient_record['service_start'] = env.now
                patient_record['wait_time_weeks'] = wait_time
                patient_record['status'] = 'seen'

                patients_seen.append(patient_record.copy())
                yield env.timeout(service_time)

        def patient_generator(env, nurses):
            """Generates new patients based on a weekly schedule."""
            # Create initial patients on waiting list
            for i in range(waiting_list_start_length):
                env.process(patient(env, f"Initial Patient {i+1}", nurses, 0))

            # Generate new patients each week
            while True:
                num_arrivals = math.ceil(random.normalvariate(patients, patients*0.2))
                num_arrivals = max(0, num_arrivals)

                for i in range(num_arrivals):
                    env.process(patient(env, f"Week {math.ceil(env.now)} Patient {i+1}",
                                      nurses, env.now))

                yield env.timeout(1)

        def monitor_queue(env, nurses):
            """Monitor queue length over time."""
            while True:
                queue_lengths.append(len(nurses.queue))
                time_points.append(env.now)
                yield env.timeout(1)  # Check every week

        # Run simulation
        env = simpy.Environment()
        nurses_resource = simpy.Resource(env, capacity=clinicians)

        # Start processes
        env.process(patient_generator(env, nurses_resource))
        env.process(monitor_queue(env, nurses_resource))

        # Run simulation
        env.run(until=sim_duration_years*52)

        with tab1:
            # Create the matplotlib graph
            fig, ax = plt.subplots(figsize=(10, 4))
            ax.plot(time_points, queue_lengths, linewidth=2, color='#1f77b4')
            ax.set_xlabel('Time (weeks)')
            ax.set_ylabel('Waiting List Length')
            ax.set_title('Waiting List Length Over Time')
            ax.grid(True, alpha=0.3)
            st.pyplot(fig)

            # Metric cards
            final_waiting_list = len(nurses_resource.queue)
            col2a, col2b, col2c = st.columns(3)

            with col2a:
                st.metric(
                    label="Final Waiting List",
                    value=final_waiting_list,
                    help="Number of patients still waiting after simulation"
                )

            with col2b:
                st.metric(
                    label="Patients Seen",
                    value=len(patients_seen),
                    help="Total number of patients who received treatment"
                )

            with col2c:
                avg_wait = sum(waiting_times) / len(waiting_times) if waiting_times else 0
                st.metric(
                    label="Average Wait (weeks)",
                    value=f"{avg_wait:.1f}",
                    help="Average waiting time for patients who were seen"
                )

        with tab2:
            # Wait time breakdown
            st.subheader("Wait Time Analysis")

            if patients_seen:
                # Convert to DataFrame for easier analysis
                df_patients = pd.DataFrame(patients_seen)

                # Calculate wait time categories
                over_18_weeks = len(df_patients[df_patients['wait_time_weeks'] > 18])
                over_36_weeks = len(df_patients[df_patients['wait_time_weeks'] > 36])
                over_52_weeks = len(df_patients[df_patients['wait_time_weeks'] > 52])

                st.write("**Patients Who Were Seen:**")
                # Display breakdown in columns
                col3a, col3b, col3c = st.columns(3)

                with col3a:
                    st.metric(
                        label="Waited > 18 weeks",
                        value=over_18_weeks,
                        delta=f"{(over_18_weeks/len(patients_seen)*100):.1f}%",
                        delta_color="off"
                    )

                with col3b:
                    st.metric(
                        label="Waited > 36 weeks",
                        value=over_36_weeks,
                        delta=f"{(over_36_weeks/len(patients_seen)*100):.1f}%",
                        delta_color="off"

                    )

                with col3c:
                    st.metric(
                        label="Waited > 52 weeks",
                        value=over_52_weeks,
                        delta=f"{(over_52_weeks/len(patients_seen)*100):.1f}%",
                        delta_color="off"
                    )

                # Optional: Show distribution histogram
                fig2, ax2 = plt.subplots(figsize=(10, 3))
                ax2.hist(df_patients['wait_time_weeks'], bins=20, alpha=0.7, color='#ff7f0e')
                ax2.axvline(x=18, color='red', linestyle='--', alpha=0.7, label='18 weeks')
                ax2.axvline(x=36, color='orange', linestyle='--', alpha=0.7, label='36 weeks')
                ax2.axvline(x=52, color='darkred', linestyle='--', alpha=0.7, label='52 weeks')
                ax2.set_xlabel('Wait Time (weeks)')
                ax2.set_ylabel('Number of Patients')
                ax2.set_title('Distribution of Wait Times - Patients Who Were Seen')
                ax2.legend()
                ax2.grid(True, alpha=0.3)
                st.pyplot(fig2)
            else:
                st.warning("No patients were seen during the simulation period.")

        with tab3:
            # Analysis for patients still waiting
            st.subheader("Patients Still Waiting")

            # Calculate current wait times for patients still in queue
            patients_still_waiting = [p for p in all_patients if p['status'] == 'waiting']

            if patients_still_waiting:
                # Calculate current wait times
                current_wait_times = []
                for patient in patients_still_waiting:
                    current_wait = (sim_duration_years*52) - patient['arrival_time']
                    patient['current_wait_weeks'] = current_wait
                    current_wait_times.append(current_wait)

                df_waiting = pd.DataFrame(patients_still_waiting)

                # Calculate wait time categories for still waiting patients
                waiting_over_18 = len(df_waiting[df_waiting['current_wait_weeks'] > 18])
                waiting_over_36 = len(df_waiting[df_waiting['current_wait_weeks'] > 36])
                waiting_over_52 = len(df_waiting[df_waiting['current_wait_weeks'] > 52])

                st.write("**Patients Still in Queue:**")
                col4a, col4b, col4c = st.columns(3)

                with col4a:
                    st.metric(
                        label="Waiting > 18 weeks",
                        value=waiting_over_18,
                        delta=f"{(waiting_over_18/len(patients_still_waiting)*100):.1f}%",
                        delta_color="off"
                    )

                with col4b:
                    st.metric(
                        label="Waiting > 36 weeks",
                        value=waiting_over_36,
                        delta=f"{(waiting_over_36/len(patients_still_waiting)*100):.1f}%",
                        delta_color="off"
                    )

                with col4c:
                    st.metric(
                        label="Waiting > 52 weeks",
                        value=waiting_over_52,
                        delta=f"{(waiting_over_52/len(patients_still_waiting)*100):.1f}%",
                        delta_color="off"
                    )

                # Additional metrics for still waiting patients
                avg_current_wait = sum(current_wait_times) / len(current_wait_times)
                max_current_wait = max(current_wait_times)

                col5a, col5b = st.columns(2)
                with col5a:
                    st.metric(
                        label="Average Current Wait",
                        value=f"{avg_current_wait:.1f} weeks",
                        help="Average wait time for patients still in queue"
                    )
                with col5b:
                    st.metric(
                        label="Longest Current Wait",
                        value=f"{max_current_wait:.1f} weeks",
                        help="Longest wait time among patients still in queue"
                    )

                # Show distribution histogram for patients still waiting
                fig3, ax3 = plt.subplots(figsize=(10, 3))
                ax3.hist(current_wait_times, bins=20, alpha=0.7, color='#d62728')
                ax3.axvline(x=18, color='red', linestyle='--', alpha=0.7, label='18 weeks')
                ax3.axvline(x=36, color='orange', linestyle='--', alpha=0.7, label='36 weeks')
                ax3.axvline(x=52, color='darkred', linestyle='--', alpha=0.7, label='52 weeks')
                ax3.set_xlabel('Current Wait Time (weeks)')
                ax3.set_ylabel('Number of Patients')
                ax3.set_title('Distribution of Current Wait Times - Patients Still Waiting')
                ax3.legend()
                ax3.grid(True, alpha=0.3)
                st.pyplot(fig3)
            else:
                st.success("No patients are currently waiting - all patients have been seen!")

    else:
        st.info("👈 Configure your simulation parameters and click 'Run Simulation' to see results")
```



##  {#webappdemo-multiple-runs data-menu-title="An Example Web App - Multiple Runs"}

```{stlite-python}
import micropip

await micropip.install("simpy")
await micropip.install("matplotlib")

import streamlit as st
import simpy
import random
import math
from matplotlib import pyplot as plt
import pandas as pd
import numpy as np

# Set page config for wide layout
st.set_page_config(layout="wide")

st.markdown(
    """
    <style>
    [data-testid="stMetricDelta"] svg {
        display: none;
    }
    </style>
    """,
    unsafe_allow_html=True
)

st.title("Healthcare Waiting List Simulation")

# Create two columns
col1, col2 = st.columns([1, 2])

# Left column - Options
with col1:
    st.header("Community Pathway Clinic")

    patients = st.slider(
        "Average new patients per week",
        min_value=5,
        max_value=50,
        value=25,
        help="This sets up a normal distribution with a mean of this value, and a standard deviation of 1/10th of this value."
    )

    waiting_list_start_length = st.number_input(
        "Initial waiting list length",
        min_value=0,
        max_value=5000,
        value=80
    )

    input_col_1, input_col_2 = st.columns([0.4, 0.6])

    clinicians = input_col_1.number_input(
        "Number of clinicians",
        min_value=1,
        max_value=20,
        value=4
    )

    patients_per_clinician_per_week = input_col_2.number_input(
        "Patients per clinician per week",
        min_value=1,
        max_value=20,
        value=5
    )

    input_col_3, input_col_4 = st.columns(2)

    sim_duration_years = input_col_3.number_input(
        "Simulation duration (years)",
        min_value=1,
        max_value=10,
        value=3
    )

    num_runs = input_col_4.number_input(
        "Number of runs",
        min_value=1,
        max_value=50,
        value=10,
        help="More runs provide better uncertainty estimates but take longer to compute"
    )

    run_simulation = st.button("Run Simulation", type="primary")

# Right column - Results
with col2:
    if run_simulation:
        st.header("Simulation Results")
        tab1, tab2, tab3 = st.tabs([
          "Waiting List",
          "Waiting List - Variability",
          "Wait Times"
          ])

        # Progress bar
        progress_bar = st.progress(0)
        status_text = st.empty()

        # Store results from all runs
        all_queue_lengths = []
        all_time_points = []
        all_final_metrics = []

        def run_single_simulation(seed):
            """Run a single simulation with given random seed"""
            # Initialize tracking variables for this run
            waiting_times = []
            queue_lengths = []
            time_points = []
            patients_seen = []
            all_patients = []

            # Set random seed for this run
            random.seed(seed)

            def patient(env, name, nurses, arrival_time):
                """A patient arrives, requests a clinician, is seen, and then leaves."""
                service_time = 1 / patients_per_clinician_per_week

                # Record patient in all_patients when they arrive
                patient_record = {
                    'name': name,
                    'arrival_time': arrival_time,
                    'service_start': None,
                    'wait_time_weeks': None,
                    'status': 'waiting'
                }
                all_patients.append(patient_record)

                with nurses.request() as request:
                    yield request
                    wait_time = env.now - arrival_time
                    waiting_times.append(wait_time)

                    # Update patient record when seen
                    patient_record['service_start'] = env.now
                    patient_record['wait_time_weeks'] = wait_time
                    patient_record['status'] = 'seen'

                    patients_seen.append(patient_record.copy())
                    yield env.timeout(service_time)

            def patient_generator(env, nurses):
                """Generates new patients based on a weekly schedule."""
                # Create initial patients on waiting list
                for i in range(waiting_list_start_length):
                    env.process(patient(env, f"Initial Patient {i+1}", nurses, 0))

                # Generate new patients each week
                while True:
                    num_arrivals = math.ceil(random.normalvariate(patients, patients*0.2))
                    num_arrivals = max(0, num_arrivals)

                    for i in range(num_arrivals):
                        env.process(patient(env, f"Week {math.ceil(env.now)} Patient {i+1}",
                                          nurses, env.now))

                    yield env.timeout(1)

            def monitor_queue(env, nurses):
                """Monitor queue length over time."""
                while True:
                    queue_lengths.append(len(nurses.queue))
                    time_points.append(env.now)
                    yield env.timeout(1)  # Check every week

            # Run simulation
            env = simpy.Environment()
            nurses_resource = simpy.Resource(env, capacity=clinicians)

            # Start processes
            env.process(patient_generator(env, nurses_resource))
            env.process(monitor_queue(env, nurses_resource))

            # Run simulation
            env.run(until=sim_duration_years*52)

            # Calculate metrics for this run
            final_waiting_list = len(nurses_resource.queue)
            avg_wait = sum(waiting_times) / len(waiting_times) if waiting_times else 0

            return {
                'queue_lengths': queue_lengths,
                'time_points': time_points,
                'final_waiting_list': final_waiting_list,
                'patients_seen': len(patients_seen),
                'avg_wait': avg_wait,
                'waiting_times': waiting_times,
                'patients_seen_data': patients_seen,
                'all_patients': all_patients
            }

        # Run multiple simulations
        for run_idx in range(num_runs):
            status_text.text(f'Running simulation {run_idx + 1} of {num_runs}...')
            progress_bar.progress((run_idx + 1) / num_runs)

            # Use different seeds for each run
            result = run_single_simulation(42 + run_idx)

            all_queue_lengths.append(result['queue_lengths'])
            all_time_points.append(result['time_points'])
            all_final_metrics.append({
                'final_waiting_list': result['final_waiting_list'],
                'patients_seen': result['patients_seen'],
                'avg_wait': result['avg_wait']
            })

        # Clear progress indicators
        progress_bar.empty()
        status_text.empty()

        # Process results for plotting
        # Find the maximum length to align all runs
        max_length = max(len(ql) for ql in all_queue_lengths)

        # Pad shorter runs with their final value
        padded_queue_lengths = []
        for i, queue_lengths in enumerate(all_queue_lengths):
            if len(queue_lengths) < max_length:
                # Pad with the last value
                padded = queue_lengths + [queue_lengths[-1]] * (max_length - len(queue_lengths))
            else:
                padded = queue_lengths[:max_length]
            padded_queue_lengths.append(padded)

        # Convert to numpy array for easier statistics
        queue_array = np.array(padded_queue_lengths)
        time_array = np.arange(max_length)  # Weeks from 0 to max_length-1

        # Calculate statistics
        mean_queue = np.mean(queue_array, axis=0)
        std_queue = np.std(queue_array, axis=0)
        percentile_25 = np.percentile(queue_array, 25, axis=0)
        percentile_75 = np.percentile(queue_array, 75, axis=0)
        min_queue = np.min(queue_array, axis=0)
        max_queue = np.max(queue_array, axis=0)

        # Create the matplotlib graph with confidence bands
        fig, ax = plt.subplots(figsize=(12, 6))

        # Plot individual runs (lightly)
        for i, queue_lengths in enumerate(padded_queue_lengths):
            ax.plot(time_array, queue_lengths, alpha=0.2, color='lightblue', linewidth=0.5)

        # Plot confidence bands
        ax.fill_between(time_array, percentile_25, percentile_75,
                       alpha=0.3, color='#1f77b4', label='25th-75th percentile')
        ax.fill_between(time_array, min_queue, max_queue,
                       alpha=0.1, color='#1f77b4', label='Min-Max range')

        # Plot mean line
        ax.plot(time_array, mean_queue, linewidth=3, color='#1f77b4', label='Mean')

        ax.set_xlabel('Time (weeks)')
        ax.set_ylabel('Waiting List Length')
        ax.set_title(f'Waiting List Length Over Time ({num_runs} simulation runs)')
        ax.grid(True, alpha=0.3)
        ax.legend()

        with tab1:
            st.pyplot(fig)

            # Summary statistics
            st.subheader("Summary Statistics Across All Runs")

            # Calculate summary metrics
            final_waiting_mean = np.mean([m['final_waiting_list'] for m in all_final_metrics])
            final_waiting_std = np.std([m['final_waiting_list'] for m in all_final_metrics])
            patients_seen_mean = np.mean([m['patients_seen'] for m in all_final_metrics])
            patients_seen_std = np.std([m['patients_seen'] for m in all_final_metrics])
            avg_wait_mean = np.mean([m['avg_wait'] for m in all_final_metrics])
            avg_wait_std = np.std([m['avg_wait'] for m in all_final_metrics])

            # Metric cards with uncertainty
            col2a, col2b, col2c = st.columns(3)

            with col2a:
                st.metric(
                    label="Final Waiting List",
                    value=f"{final_waiting_mean:.0f} ± {final_waiting_std:.0f}",
                    help=f"Mean ± standard deviation across {num_runs} runs"
                )

            with col2b:
                st.metric(
                    label="Patients Seen",
                    value=f"{patients_seen_mean:.0f} ± {patients_seen_std:.0f}",
                    help=f"Mean ± standard deviation across {num_runs} runs"
                )

            with col2c:
                st.metric(
                    label="Average Wait (weeks)",
                    value=f"{avg_wait_mean:.1f} ± {avg_wait_std:.1f}",
                    help=f"Mean ± standard deviation across {num_runs} runs"
                )

        with tab2:
            # Show distribution of final waiting list lengths
            st.subheader("Variability in Final Outcomes")

            final_waiting_lists = [m['final_waiting_list'] for m in all_final_metrics]

            # First plot - Histogram of final waiting list lengths
            fig2, ax1 = plt.subplots(figsize=(12, 4))
            ax1.hist(final_waiting_lists, bins=min(10, num_runs), alpha=0.7, color='#ff7f0e')
            ax1.axvline(x=final_waiting_mean, color='red', linestyle='--',
                      label=f'Mean: {final_waiting_mean:.0f}')
            ax1.set_xlabel('Final Waiting List Length')
            ax1.set_ylabel('Number of Runs')
            ax1.set_title('Distribution of Final Waiting List Lengths')
            ax1.legend()
            ax1.grid(True, alpha=0.3)
            st.pyplot(fig2)

            # Second plot - Box plot showing variability over time
            fig3, ax2 = plt.subplots(figsize=(12, 4))
            sample_weeks = range(0, max_length, 13)  # Sample every quarter
            sample_data = [queue_array[:, week] for week in sample_weeks if week < max_length]
            sample_labels = [f'Week {week}' for week in sample_weeks if week < max_length]

            ax2.boxplot(sample_data, labels=sample_labels)
            ax2.set_xlabel('Time Points')
            ax2.set_ylabel('Waiting List Length')
            ax2.set_title('Waiting List Variability Over Time')
            ax2.tick_params(axis='x', rotation=45)
            ax2.grid(True, alpha=0.3)
            st.pyplot(fig3)

        with tab3:
            # Show detailed analysis with variability across all runs
            st.subheader("Detailed Wait Time Analysis")

            # Collect detailed data from multiple runs for variability analysis
            all_seen_metrics = []
            all_waiting_metrics = []

            for run_idx in range(num_runs):
                # Re-run simulation to get detailed patient data
                detailed_result = run_single_simulation(42 + run_idx)
                patients_seen_data = detailed_result['patients_seen_data']
                all_patients_data = detailed_result['all_patients']

                # Calculate metrics for patients who were seen
                if patients_seen_data:
                    df_patients = pd.DataFrame(patients_seen_data)
                    seen_over_18 = len(df_patients[df_patients['wait_time_weeks'] > 18])
                    seen_over_36 = len(df_patients[df_patients['wait_time_weeks'] > 36])
                    seen_over_52 = len(df_patients[df_patients['wait_time_weeks'] > 52])
                    total_seen = len(patients_seen_data)

                    all_seen_metrics.append({
                        'over_18_count': seen_over_18,
                        'over_36_count': seen_over_36,
                        'over_52_count': seen_over_52,
                        'over_18_pct': (seen_over_18/total_seen*100) if total_seen > 0 else 0,
                        'over_36_pct': (seen_over_36/total_seen*100) if total_seen > 0 else 0,
                        'over_52_pct': (seen_over_52/total_seen*100) if total_seen > 0 else 0,
                        'total_seen': total_seen
                    })

                # Calculate metrics for patients still waiting
                patients_still_waiting = [p for p in all_patients_data if p['status'] == 'waiting']
                if patients_still_waiting:
                    # Calculate current wait times
                    current_wait_times = []
                    for patient in patients_still_waiting:
                        current_wait = (sim_duration_years*52) - patient['arrival_time']
                        current_wait_times.append(current_wait)

                    waiting_over_18 = sum(1 for wait in current_wait_times if wait > 18)
                    waiting_over_36 = sum(1 for wait in current_wait_times if wait > 36)
                    waiting_over_52 = sum(1 for wait in current_wait_times if wait > 52)
                    total_waiting = len(patients_still_waiting)

                    all_waiting_metrics.append({
                        'over_18_count': waiting_over_18,
                        'over_36_count': waiting_over_36,
                        'over_52_count': waiting_over_52,
                        'over_18_pct': (waiting_over_18/total_waiting*100) if total_waiting > 0 else 0,
                        'over_36_pct': (waiting_over_36/total_waiting*100) if total_waiting > 0 else 0,
                        'over_52_pct': (waiting_over_52/total_waiting*100) if total_waiting > 0 else 0,
                        'total_waiting': total_waiting,
                        'avg_wait': np.mean(current_wait_times) if current_wait_times else 0,
                        'max_wait': max(current_wait_times) if current_wait_times else 0
                    })

            # Calculate summary statistics for patients who were seen
            if all_seen_metrics:
                seen_18_mean = np.mean([m['over_18_count'] for m in all_seen_metrics])
                seen_18_std = np.std([m['over_18_count'] for m in all_seen_metrics])
                seen_36_mean = np.mean([m['over_36_count'] for m in all_seen_metrics])
                seen_36_std = np.std([m['over_36_count'] for m in all_seen_metrics])
                seen_52_mean = np.mean([m['over_52_count'] for m in all_seen_metrics])
                seen_52_std = np.std([m['over_52_count'] for m in all_seen_metrics])

                seen_18_pct_mean = np.mean([m['over_18_pct'] for m in all_seen_metrics])
                seen_36_pct_mean = np.mean([m['over_36_pct'] for m in all_seen_metrics])
                seen_52_pct_mean = np.mean([m['over_52_pct'] for m in all_seen_metrics])

                st.write("**Patients Who Were Seen:**")
                col3a, col3b, col3c = st.columns(3)

                with col3a:
                    st.metric(
                        label="Waited > 18 weeks",
                        value=f"{seen_18_mean:.0f} ± {seen_18_std:.0f}",
                        delta=f"{seen_18_pct_mean:.1f}% avg",
                        help=f"Mean ± std dev across {num_runs} runs",
                        delta_color="off"
                    )

                with col3b:
                    st.metric(
                        label="Waited > 36 weeks",
                        value=f"{seen_36_mean:.0f} ± {seen_36_std:.0f}",
                        delta=f"{seen_36_pct_mean:.1f}% avg",
                        help=f"Mean ± std dev across {num_runs} runs",
                        delta_color="off"
                    )

                with col3c:
                    st.metric(
                        label="Waited > 52 weeks",
                        value=f"{seen_52_mean:.0f} ± {seen_52_std:.0f}",
                        delta=f"{seen_52_pct_mean:.1f}% avg",
                        help=f"Mean ± std dev across {num_runs} runs",
                        delta_color="off"
                    )

            # Calculate summary statistics for patients still waiting
            if all_waiting_metrics:
                waiting_18_mean = np.mean([m['over_18_count'] for m in all_waiting_metrics])
                waiting_18_std = np.std([m['over_18_count'] for m in all_waiting_metrics])
                waiting_36_mean = np.mean([m['over_36_count'] for m in all_waiting_metrics])
                waiting_36_std = np.std([m['over_36_count'] for m in all_waiting_metrics])
                waiting_52_mean = np.mean([m['over_52_count'] for m in all_waiting_metrics])
                waiting_52_std = np.std([m['over_52_count'] for m in all_waiting_metrics])

                waiting_18_pct_mean = np.mean([m['over_18_pct'] for m in all_waiting_metrics])
                waiting_36_pct_mean = np.mean([m['over_36_pct'] for m in all_waiting_metrics])
                waiting_52_pct_mean = np.mean([m['over_52_pct'] for m in all_waiting_metrics])

                avg_wait_mean = np.mean([m['avg_wait'] for m in all_waiting_metrics])
                avg_wait_std = np.std([m['avg_wait'] for m in all_waiting_metrics])
                max_wait_mean = np.mean([m['max_wait'] for m in all_waiting_metrics])
                max_wait_std = np.std([m['max_wait'] for m in all_waiting_metrics])

                st.write("**Patients Still Waiting:**")
                col4a, col4b, col4c = st.columns(3)

                with col4a:
                    st.metric(
                        label="Waiting > 18 weeks",
                        value=f"{waiting_18_mean:.0f} ± {waiting_18_std:.0f}",
                        delta=f"{waiting_18_pct_mean:.1f}% avg",
                        help=f"Mean ± std dev across {num_runs} runs",
                        delta_color="off"
                    )

                with col4b:
                    st.metric(
                        label="Waiting > 36 weeks",
                        value=f"{waiting_36_mean:.0f} ± {waiting_36_std:.0f}",
                        delta=f"{waiting_36_pct_mean:.1f}% avg",
                        help=f"Mean ± std dev across {num_runs} runs",
                        delta_color="off"
                    )

                with col4c:
                    st.metric(
                        label="Waiting > 52 weeks",
                        value=f"{waiting_52_mean:.0f} ± {waiting_52_std:.0f}",
                        delta=f"{waiting_52_pct_mean:.1f}% avg",
                        help=f"Mean ± std dev across {num_runs} runs",
                        delta_color="off"
                    )

                # Additional summary metrics for patients still waiting
                col5a, col5b = st.columns(2)
                with col5a:
                    st.metric(
                        label="Average Current Wait",
                        value=f"{avg_wait_mean:.1f} ± {avg_wait_std:.1f} weeks",
                        help=f"Mean ± std dev across {num_runs} runs",
                        delta_color="off"
                    )
                with col5b:
                    st.metric(
                        label="Longest Current Wait",
                        value=f"{max_wait_mean:.1f} ± {max_wait_std:.1f} weeks",
                        help=f"Mean ± std dev across {num_runs} runs",
                        delta_color="off"
                    )

    else:
        st.info("👈 Configure your simulation parameters and click 'Run Simulation' to see results")
```



# Outputs from Models

## Metrics

Talk about the importance of defining your measurable metrics



# Exercise: The DES Playground

You're now going to have a go with an interactive app.

In the app, you are running a hospital.

You usually have 24 rooms available, which are divided between

With 24 rooms, your system is coping.

Due to building work, you are temporarily going to have 20 rooms available.

You need to reallocate the number of rooms available to different steps of the pathway - but is it possible to keep the hospital running smoothly still?

1. Run the simulation with the default parameters

2. Change some parameters


# Exercise: Design your own Discrete Event Simulation + Interface


Could get them using something like draw.io or Excalidraw?

Choose a system to model from a couple of suggestions (choose some things that are quite simple), or do one of their own systems from their post-it notes earlier.
