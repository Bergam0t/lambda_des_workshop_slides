---
title: "DESperately Seeking Simulation - Part 2"
author:
    name: Sammi Rosser, Dr Dan Chalk
    affiliation: Health Service Modelling Associates Programme Lambda
execute:
  eval: true
  echo: false
format:
  revealjs:
    embed-resources: false # necessary for stlite-quarto embedding to work
    output-file: index.html
    view-distance: 100
    height: 800
    width: 1250
    preview-links: true
    controsl: true
    controls-layout: bottom-right
    transition: convex
    plotly-connected: true
    background-transition: fade
    preload-iframes: true
    footer: "<https://hsma.co.uk>"
    theme: [default, custom.scss]
    title-slide-attributes:
        data-background-image: banner.png
    include-in-header:
      - text: |
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"><link href='https://fonts.googleapis.com/css?family=Lexend' rel='stylesheet'>
    verticator:
      themetag: 'h1'
      color: ''
      inversecolor: ''
      skipuncounted: false
      clickable: true
      position: 'auto'
      offset: '3vmin'
      autogenerate: true
      tooltip: false
      scale: 1
    revealjs-plugins:
      - verticator
      - fullscreen
filters:
  - whitphx/stlite
---

```{python}
#| echo: false

from vidigi.logging import EventLogger
from vidigi.utils import EventPosition, create_event_position_df
from vidigi.animation import animate_activity_log, generate_animation
from vidigi.prep import reshape_for_animations, generate_animation_df
import simpy
import numpy as np

import plotly.io as pio
pio.renderers.default = "notebook"
```

# Recap

## Entities...

Entities are the service users in your model.

Entities arrive and move through your system...

```{python}
#| echo: false

class Patient:
    def __init__(self, p_id):
        self.id = p_id

class SimpleActivityModel:
    def __init__(self, master_seed=42):
        self.env = simpy.Environment()
        self.patient_counter = 0
        self.patient_inter = 5
        self.logger = EventLogger(env=self.env)

        # Seed setup using numpy's SeedSequence
        self.master_seed = master_seed
        self.seed_seq = np.random.SeedSequence(master_seed)
        self.rng = np.random.default_rng(self.seed_seq)

    def generate_arrivals(self):
        while True:
            self.patient_counter += 1
            p = Patient(self.patient_counter)
            self.logger.log_arrival(entity_id=p.id)
            self.env.process(self.patient_journey(p))
            sampled_inter = self.rng.exponential(scale=self.patient_inter)
            yield self.env.timeout(sampled_inter)

    def patient_journey(self, patient):
      self.logger.log_queue(entity_id=patient.id, event="wait_here")
      yield self.env.timeout(10)
      self.logger.log_departure(entity_id=patient.id)

    def run(self):
        self.env.process(self.generate_arrivals())
        self.env.run(until=180)

model = SimpleActivityModel()
model.run()
event_log = model.logger.to_dataframe()
event_log.to_csv("test_log.csv")

animate_activity_log(
  event_log = event_log,
  event_position_df = create_event_position_df([
    EventPosition(event="wait_here", x=200 , y=25 , label="Wait Here!"),
    EventPosition(event="depart", x=300, y=10, label="Exit")
    ]),
  every_x_time_units=1,
  limit_duration=180,
  override_x_max=300,
  override_y_max=50,
  plotly_height=600,
  plotly_width=1200,
  display_stage_labels=False,
  # time_display_units="%M minutes",
  gap_between_entities=20,
  wrap_queues_at=10,
  simulation_time_unit="minutes",
  debug_write_intermediate_objects=True
)
```

## Entities go off and do different things in our model...

```{python}
#| echo: false

class Patient:
    def __init__(self, p_id, path):
        self.id = p_id
        self.path = path

class SimpleActivityModelThreeActivities:
    def __init__(self, master_seed=42):
        self.env = simpy.Environment()
        self.patient_counter = 0
        self.patient_inter = 5
        self.logger = EventLogger(env=self.env)

        # Seed setup using numpy's SeedSequence
        self.master_seed = master_seed
        self.seed_seq = np.random.SeedSequence(master_seed)
        self.rng = np.random.default_rng(self.seed_seq)

    def generate_arrivals(self):
        while True:
            self.patient_counter += 1
            path_sample = self.rng.uniform(low=0.0, high=1.0)

            if path_sample <= 0.2:
                p = Patient(self.patient_counter, path="nurse_consult")
            elif path_sample <= 0.5:
                p = Patient(self.patient_counter, path="blood_test")
            else:
                p = Patient(self.patient_counter, path="doctor_consult")

            self.logger.log_arrival(entity_id=p.id)
            self.env.process(self.patient_journey(p))
            sampled_inter = self.rng.exponential(scale=self.patient_inter)
            yield self.env.timeout(sampled_inter)

    def patient_journey(self, patient):

      self.logger.log_queue(entity_id=patient.id, event=f"wait_here_{patient.path}")

      yield self.env.timeout(self.rng.normal(loc=8, scale=1))

      self.logger.log_departure(entity_id=patient.id)

    def run(self):
        self.env.process(self.generate_arrivals())
        self.env.run(until=180)

model = SimpleActivityModelThreeActivities()
model.run()
event_log = model.logger.to_dataframe()
event_log.to_csv("test_log.csv")

animate_activity_log(
  event_log = event_log,
  event_position_df = create_event_position_df([
    EventPosition(event="wait_here_nurse_consult", x=200 , y=25 , label="Seeing a nurse"),
    EventPosition(event="wait_here_blood_test", x=200 , y=125 , label="Having a blood test"),
    EventPosition(event="wait_here_doctor_consult", x=200 , y=225 , label="Seeing a doctor"),
    EventPosition(event="depart", x=400, y=125, label="Exit")
    ]),
  every_x_time_units=1,
  limit_duration=180,
  override_x_max=300,
  override_y_max=275,
  plotly_height=600,
  plotly_width=1200,
  display_stage_labels=True,
  # time_display_units="%M minutes",
  gap_between_entities=20,
  wrap_queues_at=10,
  simulation_time_unit="minutes",
  debug_write_intermediate_objects=True
)
```

## Generators...

Generators bring entities into being.

We might have multiple generators for different kinds of patients, if they arrive at different rates.

*Example of patients arriving via ambulance and via walk-in, with clearly different arrival rates*


## Sinks

*Example of multi-step mostly linear pathway, with patients having the possibility of leaving at multiple steps*


## Activities and Resources

*Example of simple one-step resource use with a constrained resource*



## Queues

## FIFO Queues

## Priority-based Queue


## Reneging


## Balking


## Jockeying


# What-if Scenarios


## The Power of Questions



## The Code

Here's a sample of some code for a

```{python}
#| eval: false
#| echo: true

import simpy
import random
import math
import matplotlib.pyplot as plt
import argparse

# --------------------------
# Parse command-line arguments
# --------------------------
parser = argparse.ArgumentParser(description="Healthcare Waiting List Simulation")
parser.add_argument("--patients", type=int, default=25, help="Average new patients per week (default: 25)")
parser.add_argument("--clinicians", type=int, default=4, help="Number of clinicians (default: 4)")
parser.add_argument("--patients_per_clinician_per_week", type=int, default=5, help="Patients each clinician can see per week (default: 5)")
parser.add_argument("--duration_years", type=int, default=3, help="Simulation duration in years (default: 3)")
parser.add_argument("--initial_waitlist", type=int, default=0, help="Initial waiting list length (default: 0)")

args = parser.parse_args()

# --------------------------
# Assign from arguments
# --------------------------
patients = args.patients
clinicians = args.clinicians
patients_per_clinician_per_week = args.patients_per_clinician_per_week
sim_duration_years = args.duration_years
waiting_list_start_length = args.initial_waitlist

# --------------------------
# Tracking variables
# --------------------------
waiting_times = []
queue_lengths = []
time_points = []
patients_seen = []
all_patients = []

random.seed(42)

# --------------------------
# Simulation functions
# --------------------------
def patient(env, name, nurses, arrival_time):
    service_time = 1 / patients_per_clinician_per_week
    patient_record = {
        'name': name,
        'arrival_time': arrival_time,
        'service_start': None,
        'wait_time_weeks': None,
        'status': 'waiting'
    }
    all_patients.append(patient_record)

    with nurses.request() as request:
        yield request
        wait_time = env.now - arrival_time
        waiting_times.append(wait_time)

        patient_record['service_start'] = env.now
        patient_record['wait_time_weeks'] = wait_time
        patient_record['status'] = 'seen'

        patients_seen.append(patient_record.copy())
        yield env.timeout(service_time)

def patient_generator(env, nurses):
    for i in range(waiting_list_start_length):
        env.process(patient(env, f"Initial Patient {i+1}", nurses, 0))

    while True:
        num_arrivals = math.ceil(random.normalvariate(patients, patients * 0.2))
        num_arrivals = max(0, num_arrivals)
        for i in range(num_arrivals):
            env.process(patient(env, f"Week {math.ceil(env.now)} Patient {i+1}", nurses, env.now))
        yield env.timeout(1)

def monitor_queue(env, nurses):
    while True:
        queue_lengths.append(len(nurses.queue))
        time_points.append(env.now)
        yield env.timeout(1)

# --------------------------
# Run simulation
# --------------------------
env = simpy.Environment()
nurses_resource = simpy.Resource(env, capacity=clinicians)
env.process(patient_generator(env, nurses_resource))
env.process(monitor_queue(env, nurses_resource))
env.run(until=sim_duration_years * 52)

# --------------------------
# Plot results
# --------------------------
plt.figure(figsize=(10, 4))
plt.plot(time_points, queue_lengths, linewidth=2, color='#1f77b4')
plt.xlabel('Time (weeks)')
plt.ylabel('Waiting List Length')
plt.title('Waiting List Length Over Time')
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

# --------------------------
# Print summary
# --------------------------
final_waiting_list = len(nurses_resource.queue)
patients_seen_count = len(patients_seen)
avg_wait = sum(waiting_times) / len(waiting_times) if waiting_times else 0

print("\n--- Simulation Summary ---")
print(f"Final Waiting List: {final_waiting_list}")
print(f"Patients Seen: {patients_seen_count}")
print(f"Average Wait (weeks): {avg_wait:.1f}")

```

## Running the Code

:::: {.columns}

::: {.column width='25%'}

:::{.incremental .smaller}
- Ask IT for approval to install **Python**
- Install the additional packages into an **environment**
:::

:::

::: {.column width='75%'}

:::{.fragment}
Run it from the **terminal**...

![](assets/Code_Dlz655dql1.gif)
:::

:::

::::


# Web App Interfaces

##  {#webappdemo-basic data-menu-title="An Example Web App"}

```{stlite-python}
import micropip

await micropip.install("simpy")
await micropip.install("matplotlib")

import streamlit as st
import simpy
import random
import math
from matplotlib import pyplot as plt
import pandas as pd

# Set page config for wide layout
st.set_page_config(layout="wide")

st.markdown(
    """
    <style>
    [data-testid="stMetricDelta"] svg {
        display: none;
    }
    </style>
    """,
    unsafe_allow_html=True
)

st.title("Healthcare Waiting List Simulation")

# Create two columns
col1, col2 = st.columns([1, 2])

# Left column - Options
with col1:
    st.header("Community Pathway Clinic")

    patients = st.slider(
        "Average new patients per week",
        min_value=5,
        max_value=50,
        value=25,
        help="This sets up a normal distribution with a mean of this value, and a standard deviation of 1/10th of this value."
    )

    waiting_list_start_length = 0

    clinicians = st.number_input(
        "Number of clinicians",
        min_value=1,
        max_value=20,
        value=4
    )

    patients_per_clinician_per_week = st.number_input(
        "Patients per clinician per week",
        min_value=1,
        max_value=20,
        value=5
    )

    sim_duration_years = 3

    run_simulation = st.button("Run Simulation", type="primary")

# Right column - Results
with col2:
    if run_simulation:
        st.header("Simulation Results")

        # Initialize tracking variables
        waiting_times = []
        queue_lengths = []
        time_points = []
        patients_seen = []
        all_patients = []  # Track all patients including those still waiting

        # Set random seed for reproducibility
        random.seed(42)

        def patient(env, name, nurses, arrival_time):
            """A patient arrives, requests a clinician, is seen, and then leaves."""
            service_time = 1 / patients_per_clinician_per_week

            # Record patient in all_patients when they arrive
            patient_record = {
                'name': name,
                'arrival_time': arrival_time,
                'service_start': None,
                'wait_time_weeks': None,
                'status': 'waiting'
            }
            all_patients.append(patient_record)

            with nurses.request() as request:
                yield request
                wait_time = env.now - arrival_time
                waiting_times.append(wait_time)

                # Update patient record when seen
                patient_record['service_start'] = env.now
                patient_record['wait_time_weeks'] = wait_time
                patient_record['status'] = 'seen'

                patients_seen.append(patient_record.copy())
                yield env.timeout(service_time)

        def patient_generator(env, nurses):
            """Generates new patients based on a weekly schedule."""
            # Create initial patients on waiting list
            for i in range(waiting_list_start_length):
                env.process(patient(env, f"Initial Patient {i+1}", nurses, 0))

            # Generate new patients each week
            while True:
                num_arrivals = math.ceil(random.normalvariate(patients, patients*0.2))
                num_arrivals = max(0, num_arrivals)

                for i in range(num_arrivals):
                    env.process(patient(env, f"Week {math.ceil(env.now)} Patient {i+1}",
                                      nurses, env.now))

                yield env.timeout(1)

        def monitor_queue(env, nurses):
            """Monitor queue length over time."""
            while True:
                queue_lengths.append(len(nurses.queue))
                time_points.append(env.now)
                yield env.timeout(1)  # Check every week

        # Run simulation
        env = simpy.Environment()
        nurses_resource = simpy.Resource(env, capacity=clinicians)

        # Start processes
        env.process(patient_generator(env, nurses_resource))
        env.process(monitor_queue(env, nurses_resource))

        # Run simulation
        env.run(until=sim_duration_years*52)

        # Create the matplotlib graph
        fig, ax = plt.subplots(figsize=(10, 4))
        ax.plot(time_points, queue_lengths, linewidth=2, color='#1f77b4')
        ax.set_xlabel('Time (weeks)')
        ax.set_ylabel('Waiting List Length')
        ax.set_title('Waiting List Length Over Time')
        ax.grid(True, alpha=0.3)
        st.pyplot(fig)

        # Metric cards
        final_waiting_list = len(nurses_resource.queue)
        col2a, col2b, col2c = st.columns(3)

        with col2a:
            st.metric(
                label="Final Waiting List",
                value=final_waiting_list,
                help="Number of patients still waiting after simulation"
            )

        with col2b:
            st.metric(
                label="Patients Seen",
                value=len(patients_seen),
                help="Total number of patients who received treatment"
            )

    else:
        st.info("👈 Configure your simulation parameters and click 'Run Simulation' to see results")
```

## Streamlit

:::: {.columns}

::: {.column width='40%'}

:::{.incremental}

- Free Python-based web app framework

- App users don't have to install Python

- Hosting
  - free online hosting
  - on-premisis hosting
  - browser-based running

- Alternatives exit (Shiny, Dash)

:::

:::

::: {.column width='60%'}

:::{.fragment}

<iframe data-src="https://webapps.hsma.co.uk/warnings_errors_success_messages.html" style="width:100%; height:700px;"></iframe>

:::

:::

::::


## Making our app more useful

Let's return to our sample web app.

We'll add

- some extra inputs
- some analysis of the patient wait times

##  {#webappdemo-intermediate-1 data-menu-title="An Example Web App - Additional Parameters and Outputs"}

```{stlite-python}
import micropip

await micropip.install("simpy")
await micropip.install("matplotlib")

import streamlit as st
import simpy
import random
import math
from matplotlib import pyplot as plt
import pandas as pd

# Set page config for wide layout
st.set_page_config(layout="wide")

st.markdown(
    """
    <style>
    [data-testid="stMetricDelta"] svg {
        display: none;
    }
    </style>
    """,
    unsafe_allow_html=True
)

st.title("Healthcare Waiting List Simulation")

# Create two columns
col1, col2 = st.columns([1, 2])

# Left column - Options
with col1:
    st.header("Community Pathway Clinic")

    patients = st.slider(
        "Average new patients per week",
        min_value=5,
        max_value=50,
        value=25,
        help="This sets up a normal distribution with a mean of this value, and a standard deviation of 1/10th of this value."
    )

    waiting_list_start_length = st.number_input(
        "Initial waiting list length",
        min_value=0,
        max_value=5000,
        value=80
    )

    input_col_1, input_col_2 = st.columns([0.4, 0.6])

    clinicians = input_col_1.number_input(
        "Number of\nclinicians",
        min_value=1,
        max_value=20,
        value=4
    )

    patients_per_clinician_per_week = input_col_2.number_input(
        "Patients per clinician\nper week",
        min_value=1,
        max_value=20,
        value=5
    )

    sim_duration_years = st.number_input(
        "Simulation duration (years)",
        min_value=1,
        max_value=10,
        value=3
    )

    run_simulation = st.button("Run Simulation", type="primary")

# Right column - Results
with col2:
    if run_simulation:
        st.header("Simulation Results")

        tab1, tab2 = st.tabs([
          "Waiting List",
          "Wait Times"
          ])

        # Initialize tracking variables
        waiting_times = []
        queue_lengths = []
        time_points = []
        patients_seen = []
        all_patients = []  # Track all patients including those still waiting

        # Set random seed for reproducibility
        random.seed(42)

        def patient(env, name, nurses, arrival_time):
            """A patient arrives, requests a clinician, is seen, and then leaves."""
            service_time = 1 / patients_per_clinician_per_week

            # Record patient in all_patients when they arrive
            patient_record = {
                'name': name,
                'arrival_time': arrival_time,
                'service_start': None,
                'wait_time_weeks': None,
                'status': 'waiting'
            }
            all_patients.append(patient_record)

            with nurses.request() as request:
                yield request
                wait_time = env.now - arrival_time
                waiting_times.append(wait_time)

                # Update patient record when seen
                patient_record['service_start'] = env.now
                patient_record['wait_time_weeks'] = wait_time
                patient_record['status'] = 'seen'

                patients_seen.append(patient_record.copy())
                yield env.timeout(service_time)

        def patient_generator(env, nurses):
            """Generates new patients based on a weekly schedule."""
            # Create initial patients on waiting list
            for i in range(waiting_list_start_length):
                env.process(patient(env, f"Initial Patient {i+1}", nurses, 0))

            # Generate new patients each week
            while True:
                num_arrivals = math.ceil(random.normalvariate(patients, patients*0.2))
                num_arrivals = max(0, num_arrivals)

                for i in range(num_arrivals):
                    env.process(patient(env, f"Week {math.ceil(env.now)} Patient {i+1}",
                                      nurses, env.now))

                yield env.timeout(1)

        def monitor_queue(env, nurses):
            """Monitor queue length over time."""
            while True:
                queue_lengths.append(len(nurses.queue))
                time_points.append(env.now)
                yield env.timeout(1)  # Check every week

        # Run simulation
        env = simpy.Environment()
        nurses_resource = simpy.Resource(env, capacity=clinicians)

        # Start processes
        env.process(patient_generator(env, nurses_resource))
        env.process(monitor_queue(env, nurses_resource))

        # Run simulation
        env.run(until=sim_duration_years*52)

        with tab1:
            # Create the matplotlib graph
            fig, ax = plt.subplots(figsize=(10, 4))
            ax.plot(time_points, queue_lengths, linewidth=2, color='#1f77b4')
            ax.set_xlabel('Time (weeks)')
            ax.set_ylabel('Waiting List Length')
            ax.set_title('Waiting List Length Over Time')
            ax.grid(True, alpha=0.3)
            st.pyplot(fig)

            # Metric cards
            final_waiting_list = len(nurses_resource.queue)
            col2a, col2b, col2c = st.columns(3)

            with col2a:
                st.metric(
                    label="Final Waiting List",
                    value=final_waiting_list,
                    help="Number of patients still waiting after simulation"
                )

            with col2b:
                st.metric(
                    label="Patients Seen",
                    value=len(patients_seen),
                    help="Total number of patients who received treatment"
                )

            with col2c:
                avg_wait = sum(waiting_times) / len(waiting_times) if waiting_times else 0
                st.metric(
                    label="Average Wait (weeks)",
                    value=f"{avg_wait:.1f}",
                )

        with tab2:
            # Wait time breakdown
            st.subheader("Wait Time Analysis")

            if patients_seen:
                # Convert to DataFrame for easier analysis
                df_patients = pd.DataFrame(patients_seen)

                # Calculate wait time categories
                over_18_weeks = len(df_patients[df_patients['wait_time_weeks'] > 18])
                over_36_weeks = len(df_patients[df_patients['wait_time_weeks'] > 36])
                over_52_weeks = len(df_patients[df_patients['wait_time_weeks'] > 52])

                # Display breakdown in columns
                col3a, col3b, col3c = st.columns(3)

                with col3a:
                    st.metric(
                        label="Waited > 18 weeks",
                        value=over_18_weeks,
                        delta=f"{(over_18_weeks/len(patients_seen)*100):.1f}%",
                        delta_color="off"
                    )

                with col3b:
                    st.metric(
                        label="Waited > 36 weeks",
                        value=over_36_weeks,
                        delta=f"{(over_36_weeks/len(patients_seen)*100):.1f}%",
                        delta_color="off"

                    )

                with col3c:
                    st.metric(
                        label="Waited > 52 weeks",
                        value=over_52_weeks,
                        delta=f"{(over_52_weeks/len(patients_seen)*100):.1f}%",
                        delta_color="off"
                    )

                # Optional: Show distribution histogram
                fig2, ax2 = plt.subplots(figsize=(10, 3))
                ax2.hist(df_patients['wait_time_weeks'], bins=20, alpha=0.7, color='#ff7f0e')
                ax2.axvline(x=18, color='red', linestyle='--', alpha=0.7, label='18 weeks')
                ax2.axvline(x=36, color='orange', linestyle='--', alpha=0.7, label='36 weeks')
                ax2.axvline(x=52, color='darkred', linestyle='--', alpha=0.7, label='52 weeks')
                ax2.set_xlabel('Wait Time (weeks)')
                ax2.set_ylabel('Number of Patients')
                ax2.set_title('Distribution of Wait Times')
                ax2.legend()
                ax2.grid(True, alpha=0.3)
                st.pyplot(fig2)
            else:
                st.warning("No patients were seen during the simulation period.")

    else:
        st.info("👈 Configure your simulation parameters and click 'Run Simulation' to see results")
```

Are we seeing the full picture here?

##  {#webappdemo-intermediate-2 data-menu-title="An Example Web App - Better Outputs"}

Let's make it clearer what the wait times mean.

```{stlite-python}
import micropip

await micropip.install("simpy")
await micropip.install("matplotlib")

import streamlit as st
import simpy
import random
import math
from matplotlib import pyplot as plt
import pandas as pd

# Set page config for wide layout
st.set_page_config(layout="wide")

st.markdown(
    """
    <style>
    [data-testid="stMetricDelta"] svg {
        display: none;
    }
    </style>
    """,
    unsafe_allow_html=True
)

st.title("Healthcare Waiting List Simulation")

# Create two columns
col1, col2 = st.columns([1, 2])

# Left column - Options
with col1:
    st.header("Community Pathway Clinic")

    patients = st.slider(
        "Average new patients per week",
        min_value=5,
        max_value=50,
        value=25,
        help="This sets up a normal distribution with a mean of this value, and a standard deviation of 1/10th of this value."
    )

    waiting_list_start_length = st.number_input(
        "Initial waiting list length",
        min_value=0,
        max_value=5000,
        value=80
    )

    input_col_1, input_col_2 = st.columns([0.4, 0.6])

    clinicians = input_col_1.number_input(
        "Number of\nclinicians",
        min_value=1,
        max_value=20,
        value=4
    )

    patients_per_clinician_per_week = input_col_2.number_input(
        "Patients per clinician\nper week",
        min_value=1,
        max_value=20,
        value=5
    )

    sim_duration_years = st.number_input(
        "Simulation duration (years)",
        min_value=1,
        max_value=10,
        value=3
    )

    run_simulation = st.button("Run Simulation", type="primary")

# Right column - Results
with col2:
    if run_simulation:
        st.header("Simulation Results")

        tab1, tab2, tab3 = st.tabs([
          "Waiting List",
          "Wait Times - Seen",
          "Wait Times - Still Waiting"
          ])

        # Initialize tracking variables
        waiting_times = []
        queue_lengths = []
        time_points = []
        patients_seen = []
        all_patients = []  # Track all patients including those still waiting

        # Set random seed for reproducibility
        random.seed(42)

        def patient(env, name, nurses, arrival_time):
            """A patient arrives, requests a clinician, is seen, and then leaves."""
            service_time = 1 / patients_per_clinician_per_week

            # Record patient in all_patients when they arrive
            patient_record = {
                'name': name,
                'arrival_time': arrival_time,
                'service_start': None,
                'wait_time_weeks': None,
                'status': 'waiting'
            }
            all_patients.append(patient_record)

            with nurses.request() as request:
                yield request
                wait_time = env.now - arrival_time
                waiting_times.append(wait_time)

                # Update patient record when seen
                patient_record['service_start'] = env.now
                patient_record['wait_time_weeks'] = wait_time
                patient_record['status'] = 'seen'

                patients_seen.append(patient_record.copy())
                yield env.timeout(service_time)

        def patient_generator(env, nurses):
            """Generates new patients based on a weekly schedule."""
            # Create initial patients on waiting list
            for i in range(waiting_list_start_length):
                env.process(patient(env, f"Initial Patient {i+1}", nurses, 0))

            # Generate new patients each week
            while True:
                num_arrivals = math.ceil(random.normalvariate(patients, patients*0.2))
                num_arrivals = max(0, num_arrivals)

                for i in range(num_arrivals):
                    env.process(patient(env, f"Week {math.ceil(env.now)} Patient {i+1}",
                                      nurses, env.now))

                yield env.timeout(1)

        def monitor_queue(env, nurses):
            """Monitor queue length over time."""
            while True:
                queue_lengths.append(len(nurses.queue))
                time_points.append(env.now)
                yield env.timeout(1)  # Check every week

        # Run simulation
        env = simpy.Environment()
        nurses_resource = simpy.Resource(env, capacity=clinicians)

        # Start processes
        env.process(patient_generator(env, nurses_resource))
        env.process(monitor_queue(env, nurses_resource))

        # Run simulation
        env.run(until=sim_duration_years*52)

        with tab1:
            # Create the matplotlib graph
            fig, ax = plt.subplots(figsize=(10, 4))
            ax.plot(time_points, queue_lengths, linewidth=2, color='#1f77b4')
            ax.set_xlabel('Time (weeks)')
            ax.set_ylabel('Waiting List Length')
            ax.set_title('Waiting List Length Over Time')
            ax.grid(True, alpha=0.3)
            st.pyplot(fig)

            # Metric cards
            final_waiting_list = len(nurses_resource.queue)
            col2a, col2b, col2c = st.columns(3)

            with col2a:
                st.metric(
                    label="Final Waiting List",
                    value=final_waiting_list,
                    help="Number of patients still waiting after simulation"
                )

            with col2b:
                st.metric(
                    label="Patients Seen",
                    value=len(patients_seen),
                    help="Total number of patients who received treatment"
                )

            with col2c:
                avg_wait = sum(waiting_times) / len(waiting_times) if waiting_times else 0
                st.metric(
                    label="Average Wait (weeks)",
                    value=f"{avg_wait:.1f}",
                    help="Average waiting time for patients who were seen"
                )

        with tab2:
            # Wait time breakdown
            st.subheader("Wait Time Analysis")

            if patients_seen:
                # Convert to DataFrame for easier analysis
                df_patients = pd.DataFrame(patients_seen)

                # Calculate wait time categories
                over_18_weeks = len(df_patients[df_patients['wait_time_weeks'] > 18])
                over_36_weeks = len(df_patients[df_patients['wait_time_weeks'] > 36])
                over_52_weeks = len(df_patients[df_patients['wait_time_weeks'] > 52])

                st.write("**Patients Who Were Seen:**")
                # Display breakdown in columns
                col3a, col3b, col3c = st.columns(3)

                with col3a:
                    st.metric(
                        label="Waited > 18 weeks",
                        value=over_18_weeks,
                        delta=f"{(over_18_weeks/len(patients_seen)*100):.1f}%",
                        delta_color="off"
                    )

                with col3b:
                    st.metric(
                        label="Waited > 36 weeks",
                        value=over_36_weeks,
                        delta=f"{(over_36_weeks/len(patients_seen)*100):.1f}%",
                        delta_color="off"

                    )

                with col3c:
                    st.metric(
                        label="Waited > 52 weeks",
                        value=over_52_weeks,
                        delta=f"{(over_52_weeks/len(patients_seen)*100):.1f}%",
                        delta_color="off"
                    )

                # Optional: Show distribution histogram
                fig2, ax2 = plt.subplots(figsize=(10, 3))
                ax2.hist(df_patients['wait_time_weeks'], bins=20, alpha=0.7, color='#ff7f0e')
                ax2.axvline(x=18, color='red', linestyle='--', alpha=0.7, label='18 weeks')
                ax2.axvline(x=36, color='orange', linestyle='--', alpha=0.7, label='36 weeks')
                ax2.axvline(x=52, color='darkred', linestyle='--', alpha=0.7, label='52 weeks')
                ax2.set_xlabel('Wait Time (weeks)')
                ax2.set_ylabel('Number of Patients')
                ax2.set_title('Distribution of Wait Times - Patients Who Were Seen')
                ax2.legend()
                ax2.grid(True, alpha=0.3)
                st.pyplot(fig2)
            else:
                st.warning("No patients were seen during the simulation period.")

        with tab3:
            # Analysis for patients still waiting
            st.subheader("Patients Still Waiting")

            # Calculate current wait times for patients still in queue
            patients_still_waiting = [p for p in all_patients if p['status'] == 'waiting']

            if patients_still_waiting:
                # Calculate current wait times
                current_wait_times = []
                for patient in patients_still_waiting:
                    current_wait = (sim_duration_years*52) - patient['arrival_time']
                    patient['current_wait_weeks'] = current_wait
                    current_wait_times.append(current_wait)

                df_waiting = pd.DataFrame(patients_still_waiting)

                # Calculate wait time categories for still waiting patients
                waiting_over_18 = len(df_waiting[df_waiting['current_wait_weeks'] > 18])
                waiting_over_36 = len(df_waiting[df_waiting['current_wait_weeks'] > 36])
                waiting_over_52 = len(df_waiting[df_waiting['current_wait_weeks'] > 52])

                st.write("**Patients Still in Queue:**")
                col4a, col4b, col4c = st.columns(3)

                with col4a:
                    st.metric(
                        label="Waiting > 18 weeks",
                        value=waiting_over_18,
                        delta=f"{(waiting_over_18/len(patients_still_waiting)*100):.1f}%",
                        delta_color="off"
                    )

                with col4b:
                    st.metric(
                        label="Waiting > 36 weeks",
                        value=waiting_over_36,
                        delta=f"{(waiting_over_36/len(patients_still_waiting)*100):.1f}%",
                        delta_color="off"
                    )

                with col4c:
                    st.metric(
                        label="Waiting > 52 weeks",
                        value=waiting_over_52,
                        delta=f"{(waiting_over_52/len(patients_still_waiting)*100):.1f}%",
                        delta_color="off"
                    )

                # Additional metrics for still waiting patients
                avg_current_wait = sum(current_wait_times) / len(current_wait_times)
                max_current_wait = max(current_wait_times)

                col5a, col5b = st.columns(2)
                with col5a:
                    st.metric(
                        label="Average Current Wait",
                        value=f"{avg_current_wait:.1f} weeks",
                        help="Average wait time for patients still in queue"
                    )
                with col5b:
                    st.metric(
                        label="Longest Current Wait",
                        value=f"{max_current_wait:.1f} weeks",
                        help="Longest wait time among patients still in queue"
                    )

                # Show distribution histogram for patients still waiting
                fig3, ax3 = plt.subplots(figsize=(10, 3))
                ax3.hist(current_wait_times, bins=20, alpha=0.7, color='#d62728')
                ax3.axvline(x=18, color='red', linestyle='--', alpha=0.7, label='18 weeks')
                ax3.axvline(x=36, color='orange', linestyle='--', alpha=0.7, label='36 weeks')
                ax3.axvline(x=52, color='darkred', linestyle='--', alpha=0.7, label='52 weeks')
                ax3.set_xlabel('Current Wait Time (weeks)')
                ax3.set_ylabel('Number of Patients')
                ax3.set_title('Distribution of Current Wait Times - Patients Still Waiting')
                ax3.legend()
                ax3.grid(True, alpha=0.3)
                st.pyplot(fig3)
            else:
                st.success("No patients are currently waiting - all patients have been seen!")

    else:
        st.info("👈 Configure your simulation parameters and click 'Run Simulation' to see results")
```

## Introducing Variability



##  {#webappdemo-multiple-runs data-menu-title="An Example Web App - Multiple Runs"}

```{stlite-python}
import micropip

await micropip.install("simpy")
await micropip.install("matplotlib")

import streamlit as st
import simpy
import random
import math
from matplotlib import pyplot as plt
import pandas as pd
import numpy as np

# Set page config for wide layout
st.set_page_config(layout="wide")

st.markdown(
    """
    <style>
    [data-testid="stMetricDelta"] svg {
        display: none;
    }
    </style>
    """,
    unsafe_allow_html=True
)

st.title("Healthcare Waiting List Simulation")

# Create two columns
col1, col2 = st.columns([1, 2])

# Left column - Options
with col1:
    st.header("Community Pathway Clinic")

    patients = st.slider(
        "Average new patients per week",
        min_value=5,
        max_value=50,
        value=25,
        help="This sets up a normal distribution with a mean of this value, and a standard deviation of 1/10th of this value."
    )

    waiting_list_start_length = st.number_input(
        "Initial waiting list length",
        min_value=0,
        max_value=5000,
        value=80
    )

    input_col_1, input_col_2 = st.columns([0.4, 0.6])

    clinicians = input_col_1.number_input(
        "Number of clinicians",
        min_value=1,
        max_value=20,
        value=4
    )

    patients_per_clinician_per_week = input_col_2.number_input(
        "Patients per clinician per week",
        min_value=1,
        max_value=20,
        value=5
    )

    input_col_3, input_col_4 = st.columns(2)

    sim_duration_years = input_col_3.number_input(
        "Simulation duration (years)",
        min_value=1,
        max_value=10,
        value=3
    )

    num_runs = input_col_4.number_input(
        "Number of runs",
        min_value=1,
        max_value=50,
        value=10,
        help="More runs provide better uncertainty estimates but take longer to compute"
    )

    run_simulation = st.button("Run Simulation", type="primary")

# Right column - Results
with col2:
    if run_simulation:
        st.header("Simulation Results")
        tab1, tab2, tab3 = st.tabs([
          "Waiting List",
          "Waiting List - Variability",
          "Wait Times"
          ])

        # Progress bar
        progress_bar = st.progress(0)
        status_text = st.empty()

        # Store results from all runs
        all_queue_lengths = []
        all_time_points = []
        all_final_metrics = []

        def run_single_simulation(seed):
            """Run a single simulation with given random seed"""
            # Initialize tracking variables for this run
            waiting_times = []
            queue_lengths = []
            time_points = []
            patients_seen = []
            all_patients = []

            # Set random seed for this run
            random.seed(seed)

            def patient(env, name, nurses, arrival_time):
                """A patient arrives, requests a clinician, is seen, and then leaves."""
                service_time = 1 / patients_per_clinician_per_week

                # Record patient in all_patients when they arrive
                patient_record = {
                    'name': name,
                    'arrival_time': arrival_time,
                    'service_start': None,
                    'wait_time_weeks': None,
                    'status': 'waiting'
                }
                all_patients.append(patient_record)

                with nurses.request() as request:
                    yield request
                    wait_time = env.now - arrival_time
                    waiting_times.append(wait_time)

                    # Update patient record when seen
                    patient_record['service_start'] = env.now
                    patient_record['wait_time_weeks'] = wait_time
                    patient_record['status'] = 'seen'

                    patients_seen.append(patient_record.copy())
                    yield env.timeout(service_time)

            def patient_generator(env, nurses):
                """Generates new patients based on a weekly schedule."""
                # Create initial patients on waiting list
                for i in range(waiting_list_start_length):
                    env.process(patient(env, f"Initial Patient {i+1}", nurses, 0))

                # Generate new patients each week
                while True:
                    num_arrivals = math.ceil(random.normalvariate(patients, patients*0.2))
                    num_arrivals = max(0, num_arrivals)

                    for i in range(num_arrivals):
                        env.process(patient(env, f"Week {math.ceil(env.now)} Patient {i+1}",
                                          nurses, env.now))

                    yield env.timeout(1)

            def monitor_queue(env, nurses):
                """Monitor queue length over time."""
                while True:
                    queue_lengths.append(len(nurses.queue))
                    time_points.append(env.now)
                    yield env.timeout(1)  # Check every week

            # Run simulation
            env = simpy.Environment()
            nurses_resource = simpy.Resource(env, capacity=clinicians)

            # Start processes
            env.process(patient_generator(env, nurses_resource))
            env.process(monitor_queue(env, nurses_resource))

            # Run simulation
            env.run(until=sim_duration_years*52)

            # Calculate metrics for this run
            final_waiting_list = len(nurses_resource.queue)
            avg_wait = sum(waiting_times) / len(waiting_times) if waiting_times else 0

            return {
                'queue_lengths': queue_lengths,
                'time_points': time_points,
                'final_waiting_list': final_waiting_list,
                'patients_seen': len(patients_seen),
                'avg_wait': avg_wait,
                'waiting_times': waiting_times,
                'patients_seen_data': patients_seen,
                'all_patients': all_patients
            }

        # Run multiple simulations
        for run_idx in range(num_runs):
            status_text.text(f'Running simulation {run_idx + 1} of {num_runs}...')
            progress_bar.progress((run_idx + 1) / num_runs)

            # Use different seeds for each run
            result = run_single_simulation(42 + run_idx)

            all_queue_lengths.append(result['queue_lengths'])
            all_time_points.append(result['time_points'])
            all_final_metrics.append({
                'final_waiting_list': result['final_waiting_list'],
                'patients_seen': result['patients_seen'],
                'avg_wait': result['avg_wait']
            })

        # Clear progress indicators
        progress_bar.empty()
        status_text.empty()

        # Process results for plotting
        # Find the maximum length to align all runs
        max_length = max(len(ql) for ql in all_queue_lengths)

        # Pad shorter runs with their final value
        padded_queue_lengths = []
        for i, queue_lengths in enumerate(all_queue_lengths):
            if len(queue_lengths) < max_length:
                # Pad with the last value
                padded = queue_lengths + [queue_lengths[-1]] * (max_length - len(queue_lengths))
            else:
                padded = queue_lengths[:max_length]
            padded_queue_lengths.append(padded)

        # Convert to numpy array for easier statistics
        queue_array = np.array(padded_queue_lengths)
        time_array = np.arange(max_length)  # Weeks from 0 to max_length-1

        # Calculate statistics
        mean_queue = np.mean(queue_array, axis=0)
        std_queue = np.std(queue_array, axis=0)
        percentile_25 = np.percentile(queue_array, 25, axis=0)
        percentile_75 = np.percentile(queue_array, 75, axis=0)
        min_queue = np.min(queue_array, axis=0)
        max_queue = np.max(queue_array, axis=0)

        # Create the matplotlib graph with confidence bands
        fig, ax = plt.subplots(figsize=(12, 6))

        # Plot individual runs (lightly)
        for i, queue_lengths in enumerate(padded_queue_lengths):
            ax.plot(time_array, queue_lengths, alpha=0.2, color='lightblue', linewidth=0.5)

        # Plot confidence bands
        ax.fill_between(time_array, percentile_25, percentile_75,
                       alpha=0.3, color='#1f77b4', label='25th-75th percentile')
        ax.fill_between(time_array, min_queue, max_queue,
                       alpha=0.1, color='#1f77b4', label='Min-Max range')

        # Plot mean line
        ax.plot(time_array, mean_queue, linewidth=3, color='#1f77b4', label='Mean')

        ax.set_xlabel('Time (weeks)')
        ax.set_ylabel('Waiting List Length')
        ax.set_title(f'Waiting List Length Over Time ({num_runs} simulation runs)')
        ax.grid(True, alpha=0.3)
        ax.legend()

        with tab1:
            st.pyplot(fig)

            # Summary statistics
            st.subheader("Summary Statistics Across All Runs")

            # Calculate summary metrics
            final_waiting_mean = np.mean([m['final_waiting_list'] for m in all_final_metrics])
            final_waiting_std = np.std([m['final_waiting_list'] for m in all_final_metrics])
            patients_seen_mean = np.mean([m['patients_seen'] for m in all_final_metrics])
            patients_seen_std = np.std([m['patients_seen'] for m in all_final_metrics])
            avg_wait_mean = np.mean([m['avg_wait'] for m in all_final_metrics])
            avg_wait_std = np.std([m['avg_wait'] for m in all_final_metrics])

            # Metric cards with uncertainty
            col2a, col2b, col2c = st.columns(3)

            with col2a:
                st.metric(
                    label="Final Waiting List",
                    value=f"{final_waiting_mean:.0f} ± {final_waiting_std:.0f}",
                    help=f"Mean ± standard deviation across {num_runs} runs"
                )

            with col2b:
                st.metric(
                    label="Patients Seen",
                    value=f"{patients_seen_mean:.0f} ± {patients_seen_std:.0f}",
                    help=f"Mean ± standard deviation across {num_runs} runs"
                )

            with col2c:
                st.metric(
                    label="Average Wait (weeks)",
                    value=f"{avg_wait_mean:.1f} ± {avg_wait_std:.1f}",
                    help=f"Mean ± standard deviation across {num_runs} runs"
                )

        with tab2:
            # Show distribution of final waiting list lengths
            st.subheader("Variability in Final Outcomes")

            final_waiting_lists = [m['final_waiting_list'] for m in all_final_metrics]

            # First plot - Histogram of final waiting list lengths
            fig2, ax1 = plt.subplots(figsize=(12, 4))
            ax1.hist(final_waiting_lists, bins=min(10, num_runs), alpha=0.7, color='#ff7f0e')
            ax1.axvline(x=final_waiting_mean, color='red', linestyle='--',
                      label=f'Mean: {final_waiting_mean:.0f}')
            ax1.set_xlabel('Final Waiting List Length')
            ax1.set_ylabel('Number of Runs')
            ax1.set_title('Distribution of Final Waiting List Lengths')
            ax1.legend()
            ax1.grid(True, alpha=0.3)
            st.pyplot(fig2)

            # Second plot - Box plot showing variability over time
            fig3, ax2 = plt.subplots(figsize=(12, 4))
            sample_weeks = range(0, max_length, 13)  # Sample every quarter
            sample_data = [queue_array[:, week] for week in sample_weeks if week < max_length]
            sample_labels = [f'Week {week}' for week in sample_weeks if week < max_length]

            ax2.boxplot(sample_data, labels=sample_labels)
            ax2.set_xlabel('Time Points')
            ax2.set_ylabel('Waiting List Length')
            ax2.set_title('Waiting List Variability Over Time')
            ax2.tick_params(axis='x', rotation=45)
            ax2.grid(True, alpha=0.3)
            st.pyplot(fig3)

        with tab3:
            # Show detailed analysis with variability across all runs
            st.subheader("Detailed Wait Time Analysis")

            # Collect detailed data from multiple runs for variability analysis
            all_seen_metrics = []
            all_waiting_metrics = []

            for run_idx in range(num_runs):
                # Re-run simulation to get detailed patient data
                detailed_result = run_single_simulation(42 + run_idx)
                patients_seen_data = detailed_result['patients_seen_data']
                all_patients_data = detailed_result['all_patients']

                # Calculate metrics for patients who were seen
                if patients_seen_data:
                    df_patients = pd.DataFrame(patients_seen_data)
                    seen_over_18 = len(df_patients[df_patients['wait_time_weeks'] > 18])
                    seen_over_36 = len(df_patients[df_patients['wait_time_weeks'] > 36])
                    seen_over_52 = len(df_patients[df_patients['wait_time_weeks'] > 52])
                    total_seen = len(patients_seen_data)

                    all_seen_metrics.append({
                        'over_18_count': seen_over_18,
                        'over_36_count': seen_over_36,
                        'over_52_count': seen_over_52,
                        'over_18_pct': (seen_over_18/total_seen*100) if total_seen > 0 else 0,
                        'over_36_pct': (seen_over_36/total_seen*100) if total_seen > 0 else 0,
                        'over_52_pct': (seen_over_52/total_seen*100) if total_seen > 0 else 0,
                        'total_seen': total_seen
                    })

                # Calculate metrics for patients still waiting
                patients_still_waiting = [p for p in all_patients_data if p['status'] == 'waiting']
                if patients_still_waiting:
                    # Calculate current wait times
                    current_wait_times = []
                    for patient in patients_still_waiting:
                        current_wait = (sim_duration_years*52) - patient['arrival_time']
                        current_wait_times.append(current_wait)

                    waiting_over_18 = sum(1 for wait in current_wait_times if wait > 18)
                    waiting_over_36 = sum(1 for wait in current_wait_times if wait > 36)
                    waiting_over_52 = sum(1 for wait in current_wait_times if wait > 52)
                    total_waiting = len(patients_still_waiting)

                    all_waiting_metrics.append({
                        'over_18_count': waiting_over_18,
                        'over_36_count': waiting_over_36,
                        'over_52_count': waiting_over_52,
                        'over_18_pct': (waiting_over_18/total_waiting*100) if total_waiting > 0 else 0,
                        'over_36_pct': (waiting_over_36/total_waiting*100) if total_waiting > 0 else 0,
                        'over_52_pct': (waiting_over_52/total_waiting*100) if total_waiting > 0 else 0,
                        'total_waiting': total_waiting,
                        'avg_wait': np.mean(current_wait_times) if current_wait_times else 0,
                        'max_wait': max(current_wait_times) if current_wait_times else 0
                    })

            # Calculate summary statistics for patients who were seen
            if all_seen_metrics:
                seen_18_mean = np.mean([m['over_18_count'] for m in all_seen_metrics])
                seen_18_std = np.std([m['over_18_count'] for m in all_seen_metrics])
                seen_36_mean = np.mean([m['over_36_count'] for m in all_seen_metrics])
                seen_36_std = np.std([m['over_36_count'] for m in all_seen_metrics])
                seen_52_mean = np.mean([m['over_52_count'] for m in all_seen_metrics])
                seen_52_std = np.std([m['over_52_count'] for m in all_seen_metrics])

                seen_18_pct_mean = np.mean([m['over_18_pct'] for m in all_seen_metrics])
                seen_36_pct_mean = np.mean([m['over_36_pct'] for m in all_seen_metrics])
                seen_52_pct_mean = np.mean([m['over_52_pct'] for m in all_seen_metrics])

                st.write("**Patients Who Were Seen:**")
                col3a, col3b, col3c = st.columns(3)

                with col3a:
                    st.metric(
                        label="Waited > 18 weeks",
                        value=f"{seen_18_mean:.0f} ± {seen_18_std:.0f}",
                        delta=f"{seen_18_pct_mean:.1f}% avg",
                        help=f"Mean ± std dev across {num_runs} runs",
                        delta_color="off"
                    )

                with col3b:
                    st.metric(
                        label="Waited > 36 weeks",
                        value=f"{seen_36_mean:.0f} ± {seen_36_std:.0f}",
                        delta=f"{seen_36_pct_mean:.1f}% avg",
                        help=f"Mean ± std dev across {num_runs} runs",
                        delta_color="off"
                    )

                with col3c:
                    st.metric(
                        label="Waited > 52 weeks",
                        value=f"{seen_52_mean:.0f} ± {seen_52_std:.0f}",
                        delta=f"{seen_52_pct_mean:.1f}% avg",
                        help=f"Mean ± std dev across {num_runs} runs",
                        delta_color="off"
                    )

            # Calculate summary statistics for patients still waiting
            if all_waiting_metrics:
                waiting_18_mean = np.mean([m['over_18_count'] for m in all_waiting_metrics])
                waiting_18_std = np.std([m['over_18_count'] for m in all_waiting_metrics])
                waiting_36_mean = np.mean([m['over_36_count'] for m in all_waiting_metrics])
                waiting_36_std = np.std([m['over_36_count'] for m in all_waiting_metrics])
                waiting_52_mean = np.mean([m['over_52_count'] for m in all_waiting_metrics])
                waiting_52_std = np.std([m['over_52_count'] for m in all_waiting_metrics])

                waiting_18_pct_mean = np.mean([m['over_18_pct'] for m in all_waiting_metrics])
                waiting_36_pct_mean = np.mean([m['over_36_pct'] for m in all_waiting_metrics])
                waiting_52_pct_mean = np.mean([m['over_52_pct'] for m in all_waiting_metrics])

                avg_wait_mean = np.mean([m['avg_wait'] for m in all_waiting_metrics])
                avg_wait_std = np.std([m['avg_wait'] for m in all_waiting_metrics])
                max_wait_mean = np.mean([m['max_wait'] for m in all_waiting_metrics])
                max_wait_std = np.std([m['max_wait'] for m in all_waiting_metrics])

                st.write("**Patients Still Waiting:**")
                col4a, col4b, col4c = st.columns(3)

                with col4a:
                    st.metric(
                        label="Waiting > 18 weeks",
                        value=f"{waiting_18_mean:.0f} ± {waiting_18_std:.0f}",
                        delta=f"{waiting_18_pct_mean:.1f}% avg",
                        help=f"Mean ± std dev across {num_runs} runs",
                        delta_color="off"
                    )

                with col4b:
                    st.metric(
                        label="Waiting > 36 weeks",
                        value=f"{waiting_36_mean:.0f} ± {waiting_36_std:.0f}",
                        delta=f"{waiting_36_pct_mean:.1f}% avg",
                        help=f"Mean ± std dev across {num_runs} runs",
                        delta_color="off"
                    )

                with col4c:
                    st.metric(
                        label="Waiting > 52 weeks",
                        value=f"{waiting_52_mean:.0f} ± {waiting_52_std:.0f}",
                        delta=f"{waiting_52_pct_mean:.1f}% avg",
                        help=f"Mean ± std dev across {num_runs} runs",
                        delta_color="off"
                    )

                # Additional summary metrics for patients still waiting
                col5a, col5b = st.columns(2)
                with col5a:
                    st.metric(
                        label="Average Current Wait",
                        value=f"{avg_wait_mean:.1f} ± {avg_wait_std:.1f} weeks",
                        help=f"Mean ± std dev across {num_runs} runs",
                        delta_color="off"
                    )
                with col5b:
                    st.metric(
                        label="Longest Current Wait",
                        value=f"{max_wait_mean:.1f} ± {max_wait_std:.1f} weeks",
                        help=f"Mean ± std dev across {num_runs} runs",
                        delta_color="off"
                    )

    else:
        st.info("👈 Configure your simulation parameters and click 'Run Simulation' to see results")
```


## Comparing scenarios

##  {#webappdemo-multiple-runs-scenario-comparison data-menu-title="An Example Web App - Comparing Scenarios"}

```{stlite-python}
import micropip

await micropip.install("simpy")
await micropip.install("matplotlib")

import streamlit as st
import simpy
import random
import math
from matplotlib import pyplot as plt
import pandas as pd
import numpy as np

# Set page config for wide layout
st.set_page_config(layout="wide")

st.markdown(
    """
    <style>
    [data-testid="stMetricDelta"] svg {
        display: none;
    }
    </style>
    """,
    unsafe_allow_html=True
)

st.title("Healthcare Waiting List Simulation - Two Scenario Comparison")

# Shared parameters at the top
st.header("Shared Simulation Parameters")
shared_col1, shared_col2 = st.columns(2)

with shared_col1:
    sim_duration_years = st.number_input(
        "Simulation duration (years)",
        min_value=1,
        max_value=10,
        value=3
    )

with shared_col2:
    num_runs = st.number_input(
        "Number of runs",
        min_value=1,
        max_value=50,
        value=10,
        help="More runs provide better uncertainty estimates but take longer to compute"
    )

st.divider()

# Create two columns for scenarios
col1, col2 = st.columns(2)

# Left column - Scenario 1
with col1:
    st.header("Scenario 1: Current State")

    patients_1 = st.slider(
        "Average new patients per week",
        min_value=5,
        max_value=50,
        value=25,
        key="patients_1",
        help="This sets up a normal distribution with a mean of this value, and a standard deviation of 1/10th of this value."
    )

    waiting_list_start_length_1 = st.number_input(
        "Initial waiting list length",
        min_value=0,
        max_value=5000,
        value=80,
        key="waiting_1"
    )

    input_col_1a, input_col_1b = st.columns([0.4, 0.6])

    clinicians_1 = input_col_1a.number_input(
        "Number of clinicians",
        min_value=1,
        max_value=20,
        value=4,
        key="clinicians_1"
    )

    patients_per_clinician_per_week_1 = input_col_1b.number_input(
        "Patients per clinician per week",
        min_value=1,
        max_value=20,
        value=5,
        key="capacity_1"
    )

# Right column - Scenario 2
with col2:
    st.header("Scenario 2: Proposed Changes")

    patients_2 = st.slider(
        "Average new patients per week",
        min_value=5,
        max_value=50,
        value=25,
        key="patients_2",
        help="This sets up a normal distribution with a mean of this value, and a standard deviation of 1/10th of this value."
    )

    waiting_list_start_length_2 = st.number_input(
        "Initial waiting list length",
        min_value=0,
        max_value=5000,
        value=80,
        key="waiting_2"
    )

    input_col_2a, input_col_2b = st.columns([0.4, 0.6])

    clinicians_2 = input_col_2a.number_input(
        "Number of clinicians",
        min_value=1,
        max_value=20,
        value=6,
        key="clinicians_2"
    )

    patients_per_clinician_per_week_2 = input_col_2b.number_input(
        "Patients per clinician per week",
        min_value=1,
        max_value=20,
        value=5,
        key="capacity_2"
    )

# Run simulation button
st.divider()
run_simulation = st.button("Run Simulation Comparison", type="primary")

if run_simulation:
    def run_single_simulation(seed, patients, waiting_list_start_length, clinicians, patients_per_clinician_per_week):
        """Run a single simulation with given parameters and random seed"""
        # Initialize tracking variables for this run
        waiting_times = []
        queue_lengths = []
        time_points = []
        patients_seen = []
        all_patients = []

        # Set random seed for this run
        random.seed(seed)

        def patient(env, name, nurses, arrival_time):
            """A patient arrives, requests a clinician, is seen, and then leaves."""
            service_time = 1 / patients_per_clinician_per_week

            # Record patient in all_patients when they arrive
            patient_record = {
                'name': name,
                'arrival_time': arrival_time,
                'service_start': None,
                'wait_time_weeks': None,
                'status': 'waiting'
            }
            all_patients.append(patient_record)

            with nurses.request() as request:
                yield request
                wait_time = env.now - arrival_time
                waiting_times.append(wait_time)

                # Update patient record when seen
                patient_record['service_start'] = env.now
                patient_record['wait_time_weeks'] = wait_time
                patient_record['status'] = 'seen'

                patients_seen.append(patient_record.copy())
                yield env.timeout(service_time)

        def patient_generator(env, nurses):
            """Generates new patients based on a weekly schedule."""
            # Create initial patients on waiting list
            for i in range(waiting_list_start_length):
                env.process(patient(env, f"Initial Patient {i+1}", nurses, 0))

            # Generate new patients each week
            while True:
                num_arrivals = math.ceil(random.normalvariate(patients, patients*0.2))
                num_arrivals = max(0, num_arrivals)

                for i in range(num_arrivals):
                    env.process(patient(env, f"Week {math.ceil(env.now)} Patient {i+1}",
                                      nurses, env.now))

                yield env.timeout(1)

        def monitor_queue(env, nurses):
            """Monitor queue length over time."""
            while True:
                queue_lengths.append(len(nurses.queue))
                time_points.append(env.now)
                yield env.timeout(1)  # Check every week

        # Run simulation
        env = simpy.Environment()
        nurses_resource = simpy.Resource(env, capacity=clinicians)

        # Start processes
        env.process(patient_generator(env, nurses_resource))
        env.process(monitor_queue(env, nurses_resource))

        # Run simulation
        env.run(until=sim_duration_years*52)

        # Calculate metrics for this run
        final_waiting_list = len(nurses_resource.queue)
        avg_wait = sum(waiting_times) / len(waiting_times) if waiting_times else 0

        return {
            'queue_lengths': queue_lengths,
            'time_points': time_points,
            'final_waiting_list': final_waiting_list,
            'patients_seen': len(patients_seen),
            'avg_wait': avg_wait,
            'waiting_times': waiting_times,
            'patients_seen_data': patients_seen,
            'all_patients': all_patients
        }

    def run_scenario(scenario_num, patients, waiting_list_start_length, clinicians, patients_per_clinician_per_week):
        """Run all simulations for a given scenario"""
        # Progress tracking
        progress_bar = st.progress(0)
        status_text = st.empty()

        # Store results from all runs
        all_queue_lengths = []
        all_time_points = []
        all_final_metrics = []

        # Run multiple simulations
        for run_idx in range(num_runs):
            status_text.text(f'Running scenario {scenario_num} simulation {run_idx + 1} of {num_runs}...')
            progress_bar.progress((run_idx + 1) / num_runs)

            # Use different seeds for each run
            result = run_single_simulation(42 + run_idx, patients, waiting_list_start_length, clinicians, patients_per_clinician_per_week)

            all_queue_lengths.append(result['queue_lengths'])
            all_time_points.append(result['time_points'])
            all_final_metrics.append({
                'final_waiting_list': result['final_waiting_list'],
                'patients_seen': result['patients_seen'],
                'avg_wait': result['avg_wait']
            })

        # Clear progress indicators
        progress_bar.empty()
        status_text.empty()

        # Process results for plotting
        # Find the maximum length to align all runs
        max_length = max(len(ql) for ql in all_queue_lengths)

        # Pad shorter runs with their final value
        padded_queue_lengths = []
        for i, queue_lengths in enumerate(all_queue_lengths):
            if len(queue_lengths) < max_length:
                # Pad with the last value
                padded = queue_lengths + [queue_lengths[-1]] * (max_length - len(queue_lengths))
            else:
                padded = queue_lengths[:max_length]
            padded_queue_lengths.append(padded)

        # Convert to numpy array for easier statistics
        queue_array = np.array(padded_queue_lengths)
        time_array = np.arange(max_length)  # Weeks from 0 to max_length-1

        # Calculate statistics
        mean_queue = np.mean(queue_array, axis=0)
        std_queue = np.std(queue_array, axis=0)
        percentile_25 = np.percentile(queue_array, 25, axis=0)
        percentile_75 = np.percentile(queue_array, 75, axis=0)
        min_queue = np.min(queue_array, axis=0)
        max_queue = np.max(queue_array, axis=0)

        # Create the matplotlib graph with confidence bands
        fig, ax = plt.subplots(figsize=(10, 6))

        # Plot individual runs (lightly)
        for i, queue_lengths in enumerate(padded_queue_lengths):
            ax.plot(time_array, queue_lengths, alpha=0.2, color='lightblue', linewidth=0.5)

        # Plot confidence bands
        ax.fill_between(time_array, percentile_25, percentile_75,
                       alpha=0.3, color='#1f77b4', label='25th-75th percentile')
        ax.fill_between(time_array, min_queue, max_queue,
                       alpha=0.1, color='#1f77b4', label='Min-Max range')

        # Plot mean line
        ax.plot(time_array, mean_queue, linewidth=3, color='#1f77b4', label='Mean')

        ax.set_xlabel('Time (weeks)')
        ax.set_ylabel('Waiting List Length')
        ax.set_title(f'Scenario {scenario_num}: Waiting List Length Over Time ({num_runs} simulation runs)')
        ax.grid(True, alpha=0.3)
        ax.legend()

        # Calculate summary metrics
        final_waiting_mean = np.mean([m['final_waiting_list'] for m in all_final_metrics])
        final_waiting_std = np.std([m['final_waiting_list'] for m in all_final_metrics])
        patients_seen_mean = np.mean([m['patients_seen'] for m in all_final_metrics])
        patients_seen_std = np.std([m['patients_seen'] for m in all_final_metrics])
        avg_wait_mean = np.mean([m['avg_wait'] for m in all_final_metrics])
        avg_wait_std = np.std([m['avg_wait'] for m in all_final_metrics])

        # Get detailed wait time analysis
        all_seen_metrics = []
        all_waiting_metrics = []

        for run_idx in range(num_runs):
            # Re-run simulation to get detailed patient data
            detailed_result = run_single_simulation(42 + run_idx, patients, waiting_list_start_length, clinicians, patients_per_clinician_per_week)
            patients_seen_data = detailed_result['patients_seen_data']
            all_patients_data = detailed_result['all_patients']

            # Calculate metrics for patients who were seen
            if patients_seen_data:
                df_patients = pd.DataFrame(patients_seen_data)
                seen_over_18 = len(df_patients[df_patients['wait_time_weeks'] > 18])
                seen_over_36 = len(df_patients[df_patients['wait_time_weeks'] > 36])
                seen_over_52 = len(df_patients[df_patients['wait_time_weeks'] > 52])
                total_seen = len(patients_seen_data)

                all_seen_metrics.append({
                    'over_18_count': seen_over_18,
                    'over_36_count': seen_over_36,
                    'over_52_count': seen_over_52,
                    'over_18_pct': (seen_over_18/total_seen*100) if total_seen > 0 else 0,
                    'over_36_pct': (seen_over_36/total_seen*100) if total_seen > 0 else 0,
                    'over_52_pct': (seen_over_52/total_seen*100) if total_seen > 0 else 0,
                    'total_seen': total_seen
                })

            # Calculate metrics for patients still waiting
            patients_still_waiting = [p for p in all_patients_data if p['status'] == 'waiting']
            if patients_still_waiting:
                # Calculate current wait times
                current_wait_times = []
                for patient in patients_still_waiting:
                    current_wait = (sim_duration_years*52) - patient['arrival_time']
                    current_wait_times.append(current_wait)

                waiting_over_18 = sum(1 for wait in current_wait_times if wait > 18)
                waiting_over_36 = sum(1 for wait in current_wait_times if wait > 36)
                waiting_over_52 = sum(1 for wait in current_wait_times if wait > 52)
                total_waiting = len(patients_still_waiting)

                all_waiting_metrics.append({
                    'over_18_count': waiting_over_18,
                    'over_36_count': waiting_over_36,
                    'over_52_count': waiting_over_52,
                    'over_18_pct': (waiting_over_18/total_waiting*100) if total_waiting > 0 else 0,
                    'over_36_pct': (waiting_over_36/total_waiting*100) if total_waiting > 0 else 0,
                    'over_52_pct': (waiting_over_52/total_waiting*100) if total_waiting > 0 else 0,
                    'total_waiting': total_waiting,
                    'avg_wait': np.mean(current_wait_times) if current_wait_times else 0,
                    'max_wait': max(current_wait_times) if current_wait_times else 0
                })

        return {
            'fig': fig,
            'final_waiting_mean': final_waiting_mean,
            'final_waiting_std': final_waiting_std,
            'patients_seen_mean': patients_seen_mean,
            'patients_seen_std': patients_seen_std,
            'avg_wait_mean': avg_wait_mean,
            'avg_wait_std': avg_wait_std,
            'all_seen_metrics': all_seen_metrics,
            'all_waiting_metrics': all_waiting_metrics
        }

    # Run both scenarios
    scenario1_results = run_scenario(1, patients_1, waiting_list_start_length_1, clinicians_1, patients_per_clinician_per_week_1)
    scenario2_results = run_scenario(2, patients_2, waiting_list_start_length_2, clinicians_2, patients_per_clinician_per_week_2)

    # Add a comparison summary at the bottom
    st.divider()
    st.header("Key Differences")

    diff_col1, diff_col2, diff_col3 = st.columns(3)

    with diff_col1:
        final_diff = scenario2_results['final_waiting_mean'] - scenario1_results['final_waiting_mean']
        st.metric(
            label="Final Waiting List Difference",
            value=f"{final_diff:+.0f}",
            delta=f"Scenario 2 vs Scenario 1",
            delta_color="off"
        )

    with diff_col2:
        patients_diff = scenario2_results['patients_seen_mean'] - scenario1_results['patients_seen_mean']
        st.metric(
            label="Patients Seen Difference",
            value=f"{patients_diff:+.0f}",
            delta=f"Scenario 2 vs Scenario 1",
            delta_color="off"
        )

    with diff_col3:
        wait_diff = scenario2_results['avg_wait_mean'] - scenario1_results['avg_wait_mean']
        st.metric(
            label="Average Wait Difference",
            value=f"{wait_diff:+.1f} weeks",
            delta=f"Scenario 2 vs Scenario 1",
            delta_color="off"
        )

    # Display results in two columns
    st.header("Detailed Results")

    result_col1, result_col2 = st.columns(2)

    def display_scenario_results(col, scenario_num, results):
        with col:
            st.subheader(f"Scenario {scenario_num} Results")

            # Show the plot
            st.pyplot(results['fig'])

            # Summary statistics
            st.write("**Summary Statistics**")

            # Metric cards with uncertainty
            metric_col1, metric_col2, metric_col3 = st.columns(3)

            with metric_col1:
                st.metric(
                    label="Final Waiting List",
                    value=f"{results['final_waiting_mean']:.0f}",
                    delta=f"± {results['final_waiting_std']:.0f}",
                    delta_color="off",
                    help=f"Mean ± standard deviation across {num_runs} runs"
                )

            with metric_col2:
                st.metric(
                    label="Patients Seen",
                    value=f"{results['patients_seen_mean']:.0f}",
                    delta=f"± {results['patients_seen_std']:.0f}",
                    delta_color="off",
                    help=f"Mean ± standard deviation across {num_runs} runs"
                )

            with metric_col3:
                st.metric(
                    label="Average Wait (weeks)",
                    value=f"{results['avg_wait_mean']:.1f}",
                    delta=f"± {results['avg_wait_std']:.1f}",
                    delta_color="off",
                    help=f"Mean ± standard deviation across {num_runs} runs"
                )

            # Wait time analysis for patients who were seen
            if results['all_seen_metrics']:
                seen_18_mean = np.mean([m['over_18_count'] for m in results['all_seen_metrics']])
                seen_18_std = np.std([m['over_18_count'] for m in results['all_seen_metrics']])
                seen_36_mean = np.mean([m['over_36_count'] for m in results['all_seen_metrics']])
                seen_36_std = np.std([m['over_36_count'] for m in results['all_seen_metrics']])
                seen_52_mean = np.mean([m['over_52_count'] for m in results['all_seen_metrics']])
                seen_52_std = np.std([m['over_52_count'] for m in results['all_seen_metrics']])

                seen_18_pct_mean = np.mean([m['over_18_pct'] for m in results['all_seen_metrics']])
                seen_36_pct_mean = np.mean([m['over_36_pct'] for m in results['all_seen_metrics']])
                seen_52_pct_mean = np.mean([m['over_52_pct'] for m in results['all_seen_metrics']])

                st.write("**Patients Who Were Seen:**")
                seen_col1, seen_col2, seen_col3 = st.columns(3)

                with seen_col1:
                    st.metric(
                        label="Waited > 18 weeks",
                        value=f"{seen_18_mean:.0f} ± {seen_18_std:.0f}",
                        delta=f"{seen_18_pct_mean:.1f}% avg",
                        help=f"Mean ± std dev across {num_runs} runs",
                        delta_color="off"
                    )

                with seen_col2:
                    st.metric(
                        label="Waited > 36 weeks",
                        value=f"{seen_36_mean:.0f} ± {seen_36_std:.0f}",
                        delta=f"{seen_36_pct_mean:.1f}% avg",
                        help=f"Mean ± std dev across {num_runs} runs",
                        delta_color="off"
                    )

                with seen_col3:
                    st.metric(
                        label="Waited > 52 weeks",
                        value=f"{seen_52_mean:.0f} ± {seen_52_std:.0f}",
                        delta=f"{seen_52_pct_mean:.1f}% avg",
                        help=f"Mean ± std dev across {num_runs} runs",
                        delta_color="off"
                    )

            # Wait time analysis for patients still waiting
            if results['all_waiting_metrics']:
                waiting_18_mean = np.mean([m['over_18_count'] for m in results['all_waiting_metrics']])
                waiting_18_std = np.std([m['over_18_count'] for m in results['all_waiting_metrics']])
                waiting_36_mean = np.mean([m['over_36_count'] for m in results['all_waiting_metrics']])
                waiting_36_std = np.std([m['over_36_count'] for m in results['all_waiting_metrics']])
                waiting_52_mean = np.mean([m['over_52_count'] for m in results['all_waiting_metrics']])
                waiting_52_std = np.std([m['over_52_count'] for m in results['all_waiting_metrics']])

                waiting_18_pct_mean = np.mean([m['over_18_pct'] for m in results['all_waiting_metrics']])
                waiting_36_pct_mean = np.mean([m['over_36_pct'] for m in results['all_waiting_metrics']])
                waiting_52_pct_mean = np.mean([m['over_52_pct'] for m in results['all_waiting_metrics']])

                avg_wait_mean = np.mean([m['avg_wait'] for m in results['all_waiting_metrics']])
                avg_wait_std = np.std([m['avg_wait'] for m in results['all_waiting_metrics']])
                max_wait_mean = np.mean([m['max_wait'] for m in results['all_waiting_metrics']])
                max_wait_std = np.std([m['max_wait'] for m in results['all_waiting_metrics']])

                st.write("**Patients Still Waiting:**")
                waiting_col1, waiting_col2, waiting_col3 = st.columns(3)

                with waiting_col1:
                    st.metric(
                        label="Waiting > 18 weeks",
                        value=f"{waiting_18_mean:.0f} ± {waiting_18_std:.0f}",
                        delta=f"{waiting_18_pct_mean:.1f}% avg",
                        help=f"Mean ± std dev across {num_runs} runs",
                        delta_color="off"
                    )

                with waiting_col2:
                    st.metric(
                        label="Waiting > 36 weeks",
                        value=f"{waiting_36_mean:.0f} ± {waiting_36_std:.0f}",
                        delta=f"{waiting_36_pct_mean:.1f}% avg",
                        help=f"Mean ± std dev across {num_runs} runs",
                        delta_color="off"
                    )

                with waiting_col3:
                    st.metric(
                        label="Waiting > 52 weeks",
                        value=f"{waiting_52_mean:.0f} ± {waiting_52_std:.0f}",
                        delta=f"{waiting_52_pct_mean:.1f}% avg",
                        help=f"Mean ± std dev across {num_runs} runs",
                        delta_color="off"
                    )

                # Additional summary metrics for patients still waiting
                additional_col1, additional_col2 = st.columns(2)
                with additional_col1:
                    st.metric(
                        label="Average Current Wait",
                        value=f"{avg_wait_mean:.1f} ± {avg_wait_std:.1f} weeks",
                        help=f"Mean ± std dev across {num_runs} runs",
                        delta_color="off"
                    )
                with additional_col2:
                    st.metric(
                        label="Longest Current Wait",
                        value=f"{max_wait_mean:.1f} ± {max_wait_std:.1f} weeks",
                        help=f"Mean ± std dev across {num_runs} runs",
                        delta_color="off"
                    )

    # Display results for both scenarios
    display_scenario_results(result_col1, 1, scenario1_results)
    display_scenario_results(result_col2, 2, scenario2_results)

else:
    st.info("👆 Configure your simulation parameters for both scenarios and click 'Run Simulation Comparison' to see results")
```


# How to Make a Useless Model

## ... and How to Avoid that.

:::{.fragment}

A model is only as good as it's spec.

:::

## Understanding the Process

:::{.incremental}

- What is the process - *really*?
    - I mean *really really*...

- Setting the model up for failure if you don't have the experts in the process in the room from the start

- Do you actually have the data you need to parameterise the model?
:::

## Measuring Up

:::{.incremental}

- What metrics/KPIs do you want to be able to measure?

- How are you going to measure that the model reflects the current reality?

:::

## Scenarios

:::{.incremental}

- What do you need to be able to change?

- Will the simplified model logic support the scenarios you want to test?

:::

:::{.notes}

You can't just want to be able to change everything

Testing needs to be done to make sure that the outputs are sensible

:::

## Using it for decisions

:::{.incremental}

- What do you need to be able to export?

- Is this a one and done output, or an ongoing tool?

- How do you assess that it made good predictions, and refine it?

:::


# Exercise: The DES Playground

You're now going to have a go with an interactive app.

In the app, you are running a hospital.

You usually have 24 rooms available, which are divided between

With 24 rooms, your system is coping.

Due to building work, you are temporarily going to have 20 rooms available.

You need to reallocate the number of rooms available to different steps of the pathway - but is it possible to keep the hospital running smoothly still?

1. Run the simulation with the default parameters

2. Change some parameters

3.

What do you like about this app?

What would you want to change?


# Reflection

##


# Exercise: Design your own Discrete Event Simulation + Interface

We're going to take your model ideas from earlier and design a web app interface to go with them.

## What can these web apps contain?

```{stlite-python}

import streamlit as st
import numpy as np
import pandas as pd

col1, col2 = st.columns(2)

with col1:

  st.slider("Choose the average number of patients", 5, 50, value=25)

  st.slider("Choose the maximumum and minimum number of weekly patients",
            value=[10, 20],
            min_value=1,
            max_value=100)

  st.number_input("Enter the number of years the simulation should run for",
                    min_value = 1, max_value = 10, value = 3)

with col2:
  st.date_input("Choose a simulation start date")

  st.time_input("Choose a simulation start time", "08:00:00")

  st.multiselect(
    "Choose the patient types to include",
    ["High severity", "Medium severity", "Low severity"]
    )

st.divider()

clinic = st.selectbox(
  "Choose a clinic to model",
  ["Elm Clinic", "Pine Clinic"]
  )

if clinic == "Pine Clinic":
  df = pd.DataFrame([
    {"Staff Member": "Marty McFly", "Monday": 3, "Tuesday": 2, "Wednesday": 0, "Thursday": 3, "Friday": 1},
    {"Staff Member": "Dr Emmett Brown", "Monday": 1, "Tuesday": 0, "Wednesday": 3, "Thursday": 3, "Friday": 2},
    {"Staff Member": "Biff Tannen", "Monday": 3, "Tuesday": 1, "Wednesday": 3, "Thursday": 3, "Friday": 2}
  ])
else:
  df = pd.DataFrame([
    {"Staff Member": "Gary Oak", "Monday": 0, "Tuesday": 2, "Wednesday": 0, "Thursday": 3, "Friday": 0},
    {"Staff Member": "Ash Ketchum", "Monday": 0, "Tuesday": 0, "Wednesday": 3, "Thursday": 3, "Friday": 1},
    {"Staff Member": "Brock Harrison", "Monday": 0, "Tuesday": 1, "Wednesday": 2, "Thursday": 3, "Friday": 2}
  ])

st.data_editor(df.set_index("Staff Member"))

```

## And what can they output?

Text, metric cards, static plots, interactive plots, maps, downloadable reports


## Your Task



Could get them using something like draw.io or Excalidraw?

Choose a system to model from a couple of suggestions (choose some things that are quite simple), or do one of their own systems from their post-it notes earlier.
